<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">PasswordGenerator.java</span></div><h1>PasswordGenerator.java</h1><pre class="source lang-java linenums">package com.ucoruh.password;

import java.util.Random;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * @file PasswordGenerator.java
 * @class PasswordGenerator
 * @brief Utility class for generating random passwords.
 * @details This class provides methods to generate secure random passwords using configurable
 * character sets.
 */
<span class="fc" id="L16">public class PasswordGenerator {</span>

  /**
   * @brief Set of uppercase characters used for password generation
   * @param chars A-Z uppercase letters
   */
  private static final String UPPERCASE_CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

  /**
   * @brief Set of lowercase characters used for password generation
   * @param chars a-z lowercase letters
   */
  private static final String LOWERCASE_CHARS = &quot;abcdefghijklmnopqrstuvwxyz&quot;;

  /**
   * @brief Set of numeric digits used for password generation
   * @param chars 0-9 digits
   */
  private static final String DIGIT_CHARS = &quot;0123456789&quot;;

  /**
   * @brief Set of special characters used for password generation
   * @param chars Special characters including !@#$%^&amp;*()_-+=&lt;&gt;?/[]{}|
   */
  private static final String SPECIAL_CHARS = &quot;!@#$%^&amp;*()_-+=&lt;&gt;?/[]{}|&quot;;

  /**
   * @brief Combined set of all characters used for password generation
   * @param chars Combination of uppercase, lowercase, digits, and special characters
   */
  private static final String CHARACTERS = UPPERCASE_CHARS + LOWERCASE_CHARS + DIGIT_CHARS + SPECIAL_CHARS;

  /**
   * @brief Generates a random password of a given length
   * @details This method uses a random number generator and a predefined character set to
   * create a password string of the specified length. If a negative length is provided,
   * an empty string is returned.
   *
   * @param length The desired length of the password
   * @return String A randomly generated password
   */
  public static String generatePassword(int length) {
    // For backward compatibility, use all character sets
<span class="fc" id="L59">    return generatePassword(length, true, true, true, true);</span>
  }

  /**
   * @brief Generates a random password with specific character sets
   * @details This method allows selective inclusion of character sets (uppercase letters,
   * lowercase letters, digits, and special characters) in the generated password.
   * At least one character set must be included.
   *
   * @param length The desired length of the password
   * @param includeUppercase Whether to include uppercase letters (A-Z)
   * @param includeLowercase Whether to include lowercase letters (a-z)
   * @param includeDigits Whether to include digits (0-9)
   * @param includeSpecial Whether to include special characters
   * @return String A randomly generated password meeting the specified criteria
   */
  public static String generatePassword(int length, boolean includeUppercase,
                                        boolean includeLowercase, boolean includeDigits,
                                        boolean includeSpecial) {
    // Return empty string for zero or negative length
<span class="fc bfc" id="L79" title="All 2 branches covered.">    if (length &lt;= 0) {</span>
<span class="fc" id="L80">      return &quot;&quot;;</span>
    }

    // Build the character set based on includes
<span class="fc" id="L84">    StringBuilder charSetBuilder = new StringBuilder();</span>

<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (includeUppercase) charSetBuilder.append(UPPERCASE_CHARS);</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (includeLowercase) charSetBuilder.append(LOWERCASE_CHARS);</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (includeDigits) charSetBuilder.append(DIGIT_CHARS);</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">    if (includeSpecial) charSetBuilder.append(SPECIAL_CHARS);</span>

    // If no character set is selected, use lowercase as default
<span class="fc bfc" id="L95" title="All 2 branches covered.">    String charSet = charSetBuilder.length() &gt; 0 ? charSetBuilder.toString() : LOWERCASE_CHARS;</span>
    // Generate the password
<span class="fc" id="L97">    StringBuilder password = new StringBuilder(length);</span>
<span class="fc" id="L98">    Random random = new Random();</span>

    // Ensure at least one character from each selected char set
<span class="pc bpc" id="L101" title="2 of 6 branches missed.">    if (length &gt;= 1 &amp;&amp; includeUppercase &amp;&amp; password.length() &lt; length) {</span>
<span class="fc" id="L102">      password.append(UPPERCASE_CHARS.charAt(random.nextInt(UPPERCASE_CHARS.length())));</span>
    }

<span class="pc bpc" id="L105" title="1 of 6 branches missed.">    if (length &gt;= 2 &amp;&amp; includeLowercase &amp;&amp; password.length() &lt; length) {</span>
<span class="fc" id="L106">      password.append(LOWERCASE_CHARS.charAt(random.nextInt(LOWERCASE_CHARS.length())));</span>
    }

<span class="pc bpc" id="L109" title="1 of 6 branches missed.">    if (length &gt;= 3 &amp;&amp; includeDigits &amp;&amp; password.length() &lt; length) {</span>
<span class="fc" id="L110">      password.append(DIGIT_CHARS.charAt(random.nextInt(DIGIT_CHARS.length())));</span>
    }

<span class="pc bpc" id="L113" title="1 of 6 branches missed.">    if (length &gt;= 4 &amp;&amp; includeSpecial &amp;&amp; password.length() &lt; length) {</span>
<span class="fc" id="L114">      password.append(SPECIAL_CHARS.charAt(random.nextInt(SPECIAL_CHARS.length())));</span>
    }

    // Fill the rest with random characters from the selected set
<span class="fc bfc" id="L118" title="All 2 branches covered.">    while (password.length() &lt; length) {</span>
<span class="fc" id="L119">      int index = random.nextInt(charSet.length());</span>
<span class="fc" id="L120">      password.append(charSet.charAt(index));</span>
<span class="fc" id="L121">    }</span>

    // Shuffle the characters to avoid predictable patterns
<span class="fc" id="L124">    char[] passChars = password.toString().toCharArray();</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">    for (int i = passChars.length - 1; i &gt; 0; i--) {</span>
<span class="fc" id="L127">      int j = random.nextInt(i + 1);</span>
<span class="fc" id="L128">      char temp = passChars[i];</span>
<span class="fc" id="L129">      passChars[i] = passChars[j];</span>
<span class="fc" id="L130">      passChars[j] = temp;</span>
    }

<span class="fc" id="L133">    return new String(passChars);</span>
  }

  /**
   * @brief Prompts user for password length and generates a password
   * @details This method reads the desired password length from the user input using the provided
   * Scanner, then generates and prints the random password.
   *
   * @param scanner Scanner object for reading user input
   */
  public static void generate(Scanner scanner) {
<span class="fc" id="L144">    System.out.print(&quot;Enter desired password length: &quot;);</span>

    try {
<span class="fc" id="L147">      int length = Integer.parseInt(scanner.nextLine());</span>
<span class="fc" id="L148">      String newPassword = generatePassword(length);</span>
<span class="fc" id="L149">      System.out.println(&quot;Generated Password: &quot; + newPassword);</span>
<span class="fc" id="L150">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L151">      System.out.println(&quot;Invalid input. Please enter a valid number.&quot;);</span>
<span class="fc" id="L152">    }</span>
<span class="fc" id="L153">  }</span>

  // ========== KMP STRING MATCHING ALGORITHM ==========

  /**
   * @brief Computes the Longest Proper Prefix which is also Suffix (LPS) array.
   * @details This array is used by the KMP algorithm to avoid redundant comparisons.
   *
   * Time Complexity: O(m) where m is pattern length
   * Space Complexity: O(m)
   *
   * @param pattern The pattern string to compute LPS array for
   * @return int[] The LPS array
   */
  private static int[] computeLPSArray(String pattern) {
<span class="fc" id="L168">    int m = pattern.length();</span>
<span class="fc" id="L169">    int[] lps = new int[m];</span>
<span class="fc" id="L170">    int len = 0; // Length of previous longest prefix suffix</span>
<span class="fc" id="L171">    int i = 1;</span>
<span class="fc" id="L172">    lps[0] = 0; // lps[0] is always 0</span>

<span class="fc bfc" id="L174" title="All 2 branches covered.">    while (i &lt; m) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (pattern.charAt(i) == pattern.charAt(len)) {</span>
<span class="fc" id="L176">        len++;</span>
<span class="fc" id="L177">        lps[i] = len;</span>
<span class="fc" id="L178">        i++;</span>
      } else {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (len != 0) {</span>
<span class="nc" id="L181">          len = lps[len - 1];</span>
        } else {
<span class="fc" id="L183">          lps[i] = 0;</span>
<span class="fc" id="L184">          i++;</span>
        }
      }
    }

<span class="fc" id="L189">    return lps;</span>
  }

  /**
   * @brief Searches for pattern in text using KMP algorithm.
   * @details KMP (Knuth-Morris-Pratt) algorithm searches for occurrences of a pattern
   * within a text by using the LPS array to skip unnecessary comparisons.
   *
   * Time Complexity: O(n + m) where n is text length, m is pattern length
   * Space Complexity: O(m)
   *
   * @param text The text to search in
   * @param pattern The pattern to search for
   * @return int Index of first occurrence, or -1 if not found
   */
  public static int kmpSearch(String text, String pattern) {
<span class="fc bfc" id="L205" title="All 6 branches covered.">    if (text == null || pattern == null || pattern.isEmpty()) {</span>
<span class="fc" id="L206">      return -1;</span>
    }

<span class="fc" id="L209">    int n = text.length();</span>
<span class="fc" id="L210">    int m = pattern.length();</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">    if (m &gt; n) {</span>
<span class="fc" id="L213">      return -1;</span>
    }

<span class="fc" id="L216">    int[] lps = computeLPSArray(pattern);</span>
<span class="fc" id="L217">    int i = 0; // Index for text</span>
<span class="fc" id="L218">    int j = 0; // Index for pattern</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">    while (i &lt; n) {</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">      if (pattern.charAt(j) == text.charAt(i)) {</span>
<span class="fc" id="L222">        i++;</span>
<span class="fc" id="L223">        j++;</span>
      }

<span class="fc bfc" id="L226" title="All 2 branches covered.">      if (j == m) {</span>
<span class="fc" id="L227">        return i - j; // Pattern found at index i-j</span>
<span class="fc bfc" id="L228" title="All 4 branches covered.">      } else if (i &lt; n &amp;&amp; pattern.charAt(j) != text.charAt(i)) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (j != 0) {</span>
<span class="fc" id="L230">          j = lps[j - 1];</span>
        } else {
<span class="fc" id="L232">          i++;</span>
        }
      }
    }

<span class="fc" id="L237">    return -1; // Pattern not found</span>
  }

  /**
   * @brief Checks if a password contains a specific pattern.
   *
   * @param password The password to check
   * @param pattern The pattern to search for
   * @return boolean true if pattern is found, false otherwise
   */
  public static boolean containsPattern(String password, String pattern) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">    return kmpSearch(password, pattern) != -1;</span>
  }

  /**
   * @brief Checks if a password contains weak patterns.
   * @details Common weak patterns include: &quot;123&quot;, &quot;abc&quot;, &quot;password&quot;, &quot;qwerty&quot;, etc.
   *
   * @param password The password to check
   * @return boolean true if weak pattern found, false otherwise
   */
  public static boolean isWeakPattern(String password) {
<span class="fc bfc" id="L259" title="All 4 branches covered.">    if (password == null || password.isEmpty()) {</span>
<span class="fc" id="L260">      return true;</span>
    }

    // Common weak patterns
<span class="fc" id="L264">    String[] weakPatterns = {</span>
      &quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;123456&quot;,
      &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;,
      &quot;password&quot;, &quot;pass&quot;, &quot;pwd&quot;,
      &quot;qwerty&quot;, &quot;admin&quot;, &quot;user&quot;,
      &quot;000&quot;, &quot;111&quot;, &quot;aaa&quot;,
      &quot;password123&quot;, &quot;admin123&quot;
    };
    // Check case-insensitive
<span class="fc" id="L273">    String lowerPassword = password.toLowerCase();</span>

<span class="fc bfc" id="L275" title="All 2 branches covered.">    for (String pattern : weakPatterns) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      if (containsPattern(lowerPassword, pattern)) {</span>
<span class="fc" id="L277">        return true;</span>
      }
    }

    // Check for sequential numbers (ascending)
<span class="fc bfc" id="L282" title="All 2 branches covered.">    for (int i = 0; i &lt; password.length() - 2; i++) {</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">      if (Character.isDigit(password.charAt(i)) &amp;&amp;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">          Character.isDigit(password.charAt(i + 1)) &amp;&amp;</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">          Character.isDigit(password.charAt(i + 2))) {</span>
<span class="fc" id="L286">        int d1 = password.charAt(i) - '0';</span>
<span class="fc" id="L287">        int d2 = password.charAt(i + 1) - '0';</span>
<span class="fc" id="L288">        int d3 = password.charAt(i + 2) - '0';</span>

<span class="pc bpc" id="L290" title="1 of 4 branches missed.">        if (d2 == d1 + 1 &amp;&amp; d3 == d2 + 1) {</span>
<span class="fc" id="L291">          return true; // Sequential like 123, 456, 789</span>
        }
      }
    }

    // Check for repeated characters (3 or more)
<span class="fc bfc" id="L297" title="All 2 branches covered.">    for (int i = 0; i &lt; password.length() - 2; i++) {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">      if (password.charAt(i) == password.charAt(i + 1) &amp;&amp;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">          password.charAt(i) == password.charAt(i + 2)) {</span>
<span class="nc" id="L300">        return true; // Repeated like aaa, 111</span>
      }
    }

<span class="fc" id="L304">    return false;</span>
  }

  /**
   * @brief Generates a strong password that doesn't contain weak patterns.
   * @details Keeps generating passwords until one passes the weak pattern check.
   *
   * @param length Desired password length
   * @return String A strong password
   */
  public static String generateStrongPassword(int length) {
    String password;
<span class="fc" id="L316">    int maxAttempts = 100;</span>
<span class="fc" id="L317">    int attempts = 0;</span>

    do {
<span class="fc" id="L320">      password = generatePassword(length);</span>
<span class="fc" id="L321">      attempts++;</span>
<span class="pc bpc" id="L322" title="3 of 4 branches missed.">    } while (isWeakPattern(password) &amp;&amp; attempts &lt; maxAttempts);</span>

<span class="fc" id="L324">    return password;</span>
  }

  // ========== HUFFMAN CODING FOR PASSWORD COMPRESSION ==========

  /**
   * @brief Huffman Tree Node for encoding/decoding.
   * @details Used in Huffman Coding algorithm for lossless compression.
   */
  public static class HuffmanNode implements Comparable&lt;HuffmanNode&gt; {
    char character;
    int frequency;
    HuffmanNode left;
    HuffmanNode right;

    /**
     * @brief Constructor for leaf nodes (actual characters).
     */
<span class="fc" id="L342">    public HuffmanNode(char character, int frequency) {</span>
<span class="fc" id="L343">      this.character = character;</span>
<span class="fc" id="L344">      this.frequency = frequency;</span>
<span class="fc" id="L345">      this.left = null;</span>
<span class="fc" id="L346">      this.right = null;</span>
<span class="fc" id="L347">    }</span>

    /**
     * @brief Constructor for internal nodes.
     */
<span class="fc" id="L352">    public HuffmanNode(int frequency, HuffmanNode left, HuffmanNode right) {</span>
<span class="fc" id="L353">      this.character = '\0';</span>
<span class="fc" id="L354">      this.frequency = frequency;</span>
<span class="fc" id="L355">      this.left = left;</span>
<span class="fc" id="L356">      this.right = right;</span>
<span class="fc" id="L357">    }</span>

    /**
     * @brief Checks if node is a leaf.
     */
    public boolean isLeaf() {
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">      return left == null &amp;&amp; right == null;</span>
    }

    @Override
    public int compareTo(HuffmanNode other) {
<span class="fc" id="L368">      return Integer.compare(this.frequency, other.frequency);</span>
    }
  }

  /**
   * @brief Builds Huffman tree from character frequencies.
   * @details Uses a priority queue to build optimal encoding tree.
   *
   * @param frequencies Map of character frequencies
   * @return Root of Huffman tree
   */
  public static HuffmanNode buildHuffmanTree(Map&lt;Character, Integer&gt; frequencies) {
<span class="fc bfc" id="L380" title="All 4 branches covered.">    if (frequencies == null || frequencies.isEmpty()) {</span>
<span class="fc" id="L381">      return null;</span>
    }

<span class="fc" id="L384">    PriorityQueue&lt;HuffmanNode&gt; pq = new PriorityQueue&lt;&gt;();</span>

    // Create leaf nodes for each character
<span class="fc bfc" id="L387" title="All 2 branches covered.">    for (Map.Entry&lt;Character, Integer&gt; entry : frequencies.entrySet()) {</span>
<span class="fc" id="L388">      pq.offer(new HuffmanNode(entry.getKey(), entry.getValue()));</span>
<span class="fc" id="L389">    }</span>

    // Build tree by combining nodes
<span class="fc bfc" id="L392" title="All 2 branches covered.">    while (pq.size() &gt; 1) {</span>
<span class="fc" id="L393">      HuffmanNode left = pq.poll();</span>
<span class="fc" id="L394">      HuffmanNode right = pq.poll();</span>
<span class="fc" id="L395">      HuffmanNode parent = new HuffmanNode(</span>
        left.frequency + right.frequency, left, right
      );
<span class="fc" id="L398">      pq.offer(parent);</span>
<span class="fc" id="L399">    }</span>

<span class="fc" id="L401">    return pq.poll();</span>
  }

  /**
   * @brief Generates Huffman codes from tree.
   * @details Traverses tree to generate binary codes for each character.
   *
   * @param root Root of Huffman tree
   * @param code Current code string
   * @param huffmanCodes Map to store character codes
   */
  private static void generateCodesHelper(HuffmanNode root, String code,
                                          Map&lt;Character, String&gt; huffmanCodes) {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">    if (root == null) {</span>
<span class="nc" id="L415">      return;</span>
    }

<span class="fc bfc" id="L418" title="All 2 branches covered.">    if (root.isLeaf()) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">      huffmanCodes.put(root.character, code.isEmpty() ? &quot;0&quot; : code);</span>
<span class="fc" id="L420">      return;</span>
    }

<span class="fc" id="L423">    generateCodesHelper(root.left, code + &quot;0&quot;, huffmanCodes);</span>
<span class="fc" id="L424">    generateCodesHelper(root.right, code + &quot;1&quot;, huffmanCodes);</span>
<span class="fc" id="L425">  }</span>

  /**
   * @brief Generates Huffman codes for all characters.
   *
   * @param root Root of Huffman tree
   * @return Map of character to Huffman code
   */
  public static Map&lt;Character, String&gt; generateHuffmanCodes(HuffmanNode root) {
<span class="fc" id="L434">    Map&lt;Character, String&gt; huffmanCodes = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">    if (root != null) {</span>
<span class="fc" id="L437">      generateCodesHelper(root, &quot;&quot;, huffmanCodes);</span>
    }

<span class="fc" id="L440">    return huffmanCodes;</span>
  }

  /**
   * @brief Compresses password using Huffman coding.
   * @details Returns binary string representation of compressed password.
   *
   * @param password Password to compress
   * @return Compressed password as binary string, or empty if input is invalid
   */
  public static String compressPassword(String password) {
<span class="fc bfc" id="L451" title="All 4 branches covered.">    if (password == null || password.isEmpty()) {</span>
<span class="fc" id="L452">      return &quot;&quot;;</span>
    }

    // Calculate character frequencies
<span class="fc" id="L456">    Map&lt;Character, Integer&gt; frequencies = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L458" title="All 2 branches covered.">    for (char c : password.toCharArray()) {</span>
<span class="fc" id="L459">      frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);</span>
    }

    // Build Huffman tree
<span class="fc" id="L463">    HuffmanNode root = buildHuffmanTree(frequencies);</span>

<span class="pc bpc" id="L465" title="1 of 2 branches missed.">    if (root == null) {</span>
<span class="nc" id="L466">      return &quot;&quot;;</span>
    }

    // Generate codes
<span class="fc" id="L470">    Map&lt;Character, String&gt; codes = generateHuffmanCodes(root);</span>
    // Encode password
<span class="fc" id="L472">    StringBuilder compressed = new StringBuilder();</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">    for (char c : password.toCharArray()) {</span>
<span class="fc" id="L475">      compressed.append(codes.get(c));</span>
    }

<span class="fc" id="L478">    return compressed.toString();</span>
  }

  /**
   * @brief Decompresses password using Huffman tree.
   * @details Traverses tree using binary string to decode original password.
   *
   * @param compressed Compressed binary string
   * @param root Root of Huffman tree
   * @return Decompressed password, or empty if input is invalid
   */
  public static String decompressPassword(String compressed, HuffmanNode root) {
<span class="fc bfc" id="L490" title="All 6 branches covered.">    if (compressed == null || compressed.isEmpty() || root == null) {</span>
<span class="fc" id="L491">      return &quot;&quot;;</span>
    }

<span class="fc" id="L494">    StringBuilder decompressed = new StringBuilder();</span>

    // Special case: single character tree (root is a leaf)
<span class="fc bfc" id="L497" title="All 2 branches covered.">    if (root.isLeaf()) {</span>
      // Each bit represents one occurrence of the character
<span class="fc bfc" id="L499" title="All 2 branches covered.">      for (int i = 0; i &lt; compressed.length(); i++) {</span>
<span class="fc" id="L500">        decompressed.append(root.character);</span>
      }

<span class="fc" id="L503">      return decompressed.toString();</span>
    }

<span class="fc" id="L506">    HuffmanNode current = root;</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">    for (char bit : compressed.toCharArray()) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">      if (bit == '0') {</span>
<span class="fc" id="L510">        current = current.left;</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">      } else if (bit == '1') {</span>
<span class="fc" id="L512">        current = current.right;</span>
      }

<span class="pc bpc" id="L515" title="1 of 4 branches missed.">      if (current != null &amp;&amp; current.isLeaf()) {</span>
<span class="fc" id="L516">        decompressed.append(current.character);</span>
<span class="fc" id="L517">        current = root;</span>
      }
    }

<span class="fc" id="L521">    return decompressed.toString();</span>
  }

  /**
   * @brief Calculates compression ratio.
   * @details Compares original size (8 bits per char) vs compressed size.
   *
   * @param original Original password
   * @param compressed Compressed binary string
   * @return Compression ratio (0-100%), or 0 if invalid
   */
  public static double getCompressionRatio(String original, String compressed) {
<span class="fc bfc" id="L533" title="All 6 branches covered.">    if (original == null || original.isEmpty() ||</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        compressed == null || compressed.isEmpty()) {</span>
<span class="fc" id="L535">      return 0.0;</span>
    }

<span class="fc" id="L538">    int originalBits = original.length() * 8;</span>
<span class="fc" id="L539">    int compressedBits = compressed.length();</span>
<span class="fc" id="L540">    return (1.0 - ((double) compressedBits / originalBits)) * 100.0;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>