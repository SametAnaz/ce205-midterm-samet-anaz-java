<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilePasswordStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">FilePasswordStorage.java</span></div><h1>FilePasswordStorage.java</h1><pre class="source lang-java linenums">package com.ucoruh.password;

import java.io.*;
import java.util.*;

/**
 * @file FilePasswordStorage.java
 * @class FilePasswordStorage
 * @brief Implementation of InterfacePasswordStorage using file-based storage.
 * @author Password Manager Team
 * @version 1.0
 *
 * This class provides file-based operations to store, retrieve, update, and delete password entries.
 * All password data is encrypted using the master password.
 */
public class FilePasswordStorage implements InterfacePasswordStorage {
  /**
   * @brief File name used for file-based password storage.
   *
   * This static final field holds the file name where password entries are stored
   * when using a file-based storage mechanism.
   */
  private static final String FILE = &quot;passwords.txt&quot;;

  /**
   * @brief The master password used for encryption/decryption.
   */
  private final String masterPassword;

  /**
   * @brief Constructor that initializes storage with the master password.
   *
   * @param masterPassword The master password for encryption/decryption.
   */
<span class="fc" id="L35">  public FilePasswordStorage(String masterPassword) {</span>
<span class="fc" id="L36">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L37">  }</span>

  /**
   * @brief Adds a new password entry to the file-based storage.
   *
   * This method prompts the user to enter the service, username, and password, then creates a Password
   * object and appends its details to the passwords file.
   *
   * @param scanner the Scanner object used to obtain user input.
   */
  @Override
  public void add(Scanner scanner) {
<span class="fc" id="L49">    System.out.print(&quot;Service: &quot;);</span>
<span class="fc" id="L50">    String service = scanner.nextLine();</span>
<span class="fc" id="L51">    System.out.print(&quot;Username: &quot;);</span>
<span class="fc" id="L52">    String user = scanner.nextLine();</span>
<span class="fc" id="L53">    System.out.print(&quot;Password: &quot;);</span>
<span class="fc" id="L54">    String pass = scanner.nextLine();</span>
<span class="fc" id="L55">    Password p = new Password(service, user, pass);</span>
<span class="fc" id="L56">    List&lt;Password&gt; passwords = readAll();</span>
    // Check if service already exists
<span class="fc" id="L58">    boolean exists = passwords.stream()</span>
<span class="pc" id="L59">                     .anyMatch(pwd -&gt; pwd.getService().equalsIgnoreCase(service));</span>

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">    if (exists) {</span>
<span class="nc" id="L62">      System.out.println(&quot;A password for this service already exists. Use update option to modify it.&quot;);</span>
<span class="nc" id="L63">      return;</span>
    }

<span class="fc" id="L66">    passwords.add(p);</span>
<span class="fc" id="L67">    writeAll(passwords);</span>
<span class="fc" id="L68">    System.out.println(&quot;Password saved successfully.&quot;);</span>
<span class="fc" id="L69">  }</span>

  /**
   * @brief Displays all stored password entries.
   *
   * This method reads all password entries from the file and prints them to the console.
   */
  @Override
  public void view() {
<span class="fc" id="L78">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L81">      System.out.println(&quot;No records found.&quot;);</span>
    } else {
<span class="fc bfc" id="L83" title="All 2 branches covered.">      for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="fc" id="L84">        System.out.println((i + 1) + &quot;. &quot; + list.get(i));</span>
      }
    }
<span class="fc" id="L87">  }</span>

  /**
   * @brief Updates an existing password entry.
   *
   * This method prompts the user for the service to update and, if found, updates its username and password.
   *
   * @param scanner the Scanner object used to obtain user input for the update.
   */
  @Override
  public void update(Scanner scanner) {
<span class="fc" id="L98">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L101">      System.out.println(&quot;No records found.&quot;);</span>
<span class="fc" id="L102">      return;</span>
    }

<span class="fc" id="L105">    System.out.print(&quot;Service to update: &quot;);</span>
<span class="fc" id="L106">    String target = scanner.nextLine();</span>
<span class="fc" id="L107">    boolean updated = false;</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">    for (Password p : list) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">      if (p.getService().equalsIgnoreCase(target)) {</span>
<span class="fc" id="L111">        System.out.print(&quot;New username (leave blank to keep current '&quot; + p.getUsername() + &quot;'): &quot;);</span>
<span class="fc" id="L112">        String username = scanner.nextLine();</span>

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (!username.trim().isEmpty()) {</span>
<span class="fc" id="L115">          p.setUsername(username);</span>
        }

<span class="fc" id="L118">        System.out.print(&quot;New password (leave blank to keep current): &quot;);</span>
<span class="fc" id="L119">        String password = scanner.nextLine();</span>

<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (!password.trim().isEmpty()) {</span>
<span class="fc" id="L122">          p.setPassword(password);</span>
        }

<span class="fc" id="L125">        updated = true;</span>
<span class="fc" id="L126">        break;</span>
      }
<span class="fc" id="L128">    }</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (updated) {</span>
<span class="fc" id="L131">      writeAll(list);</span>
<span class="fc" id="L132">      System.out.println(&quot;Password updated successfully.&quot;);</span>
    } else {
<span class="fc" id="L134">      System.out.println(&quot;Service not found.&quot;);</span>
    }
<span class="fc" id="L136">  }</span>

  /**
   * @brief Deletes a password entry from the file-based storage.
   *
   * This method prompts the user for the service name of the entry to delete and removes the entry from the file.
   *
   * @param scanner the Scanner object used to obtain user input for deletion.
   */
  @Override
  public void delete(Scanner scanner) {
<span class="fc" id="L147">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L150">      System.out.println(&quot;No records found.&quot;);</span>
<span class="fc" id="L151">      return;</span>
    }

<span class="fc" id="L154">    System.out.print(&quot;Service to delete: &quot;);</span>
<span class="fc" id="L155">    String target = scanner.nextLine();</span>
<span class="fc" id="L156">    boolean removed = list.removeIf(p -&gt; p.getService().equalsIgnoreCase(target));</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">    if (removed) {</span>
<span class="fc" id="L159">      writeAll(list);</span>
<span class="fc" id="L160">      System.out.println(&quot;Password deleted successfully.&quot;);</span>
    } else {
<span class="fc" id="L162">      System.out.println(&quot;Service not found.&quot;);</span>
    }
<span class="fc" id="L164">  }</span>

  /**
   * @brief Reads all password entries from the file.
   *
   * This method opens the file and reads each line, decrypts the data,
   * and converts it into Password objects. All valid entries are returned as a list.
   *
   * @return a List of Password objects representing the stored password entries.
   */
  @Override
  public List&lt;Password&gt; readAll() {
<span class="fc" id="L176">    List&lt;Password&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">    File file = new File(FILE);</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">    if (!file.exists()) {</span>
<span class="fc" id="L180">      return list;</span>
    }

<span class="fc" id="L183">    try (BufferedReader reader = new BufferedReader(new FileReader(file))) {</span>
      String line;

<span class="fc bfc" id="L186" title="All 2 branches covered.">      while ((line = reader.readLine()) != null) {</span>
        try {
          // Decrypt the line
<span class="fc" id="L189">          String decrypted = EncryptionUtil.decrypt(line, masterPassword);</span>
<span class="fc" id="L190">          String[] parts = decrypted.split(&quot;,&quot;);</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">          if (parts.length == 3) {</span>
<span class="fc" id="L193">            list.add(new Password(parts[0], parts[1], parts[2]));</span>
          }
<span class="fc" id="L195">        } catch (Exception e) {</span>
          // Skip lines that cannot be decrypted
<span class="fc" id="L197">          System.out.println(&quot;Warning: Could not decrypt a password entry.&quot;);</span>
<span class="fc" id="L198">        }</span>
      }
<span class="nc" id="L200">    } catch (IOException e) {</span>
<span class="nc" id="L201">      System.out.println(&quot;Error reading password file: &quot; + e.getMessage());</span>
<span class="fc" id="L202">    }</span>

<span class="fc" id="L204">    return list;</span>
  }

  /**
   * @brief Writes the list of password entries to the file.
   *
   * This method clears the existing content of the file and writes all password entries
   * from the provided list, encrypting each entry.
   *
   * @param list a List of Password objects to be written to the file.
   */
  @Override
  public void writeAll(List&lt;Password&gt; list) {
<span class="fc" id="L217">    try (BufferedWriter writer = new BufferedWriter(new FileWriter(FILE))) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">      for (Password p : list) {</span>
<span class="fc" id="L219">        String data = p.getService() + &quot;,&quot; + p.getUsername() + &quot;,&quot; + p.getPassword();</span>

        try {
          // Encrypt the data
<span class="fc" id="L223">          String encrypted = EncryptionUtil.encrypt(data, masterPassword);</span>
<span class="fc" id="L224">          writer.write(encrypted);</span>
<span class="fc" id="L225">          writer.newLine();</span>
<span class="nc" id="L226">        } catch (Exception e) {</span>
<span class="nc" id="L227">          System.out.println(&quot;Error encrypting password for &quot; + p.getService() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L228">        }</span>
<span class="fc" id="L229">      }</span>
<span class="fc" id="L230">    } catch (IOException e) {</span>
<span class="fc" id="L231">      System.out.println(&quot;Error writing to password file: &quot; + e.getMessage());</span>
<span class="fc" id="L232">    }</span>
<span class="fc" id="L233">  }</span>

  // ========== XOR LINKED LIST FOR AUDIT LOG ==========

  /**
   * @brief XOR Linked List implementation for efficient storage audit log.
   * @details Uses XOR concept to store both prev and next pointers efficiently.
   * In Java, we simulate XOR behavior since we don't have direct memory access.
   *
   * Time Complexity:
   * - insert: O(1)
   * - traverse: O(n)
   * - delete: O(n)
   *
   * Space Complexity: O(n)
   */
  public static class XORLinkedList {
    /**
     * @brief Node for XOR Linked List.
     * In a true XOR linked list, npx would contain XOR of prev and next addresses.
     * In Java, we maintain references directly but follow XOR traversal logic.
     */
    private static class Node {
      String operation; // &quot;ADD&quot;, &quot;UPDATE&quot;, &quot;DELETE&quot;, &quot;VIEW&quot;
      String service;
      long timestamp;
      Node prev; // Previous node
      Node next; // Next node

<span class="fc" id="L262">      Node(String operation, String service) {</span>
<span class="fc" id="L263">        this.operation = operation;</span>
<span class="fc" id="L264">        this.service = service;</span>
<span class="fc" id="L265">        this.timestamp = System.currentTimeMillis();</span>
<span class="fc" id="L266">        this.prev = null;</span>
<span class="fc" id="L267">        this.next = null;</span>
<span class="fc" id="L268">      }</span>
    }

    private Node head;
    private Node tail;
    private int size;

    /**
     * @brief Constructor initializes empty XOR linked list.
     */
<span class="fc" id="L278">    public XORLinkedList() {</span>
<span class="fc" id="L279">      this.head = null;</span>
<span class="fc" id="L280">      this.tail = null;</span>
<span class="fc" id="L281">      this.size = 0;</span>
<span class="fc" id="L282">    }</span>

    /**
     * @brief Inserts a new audit entry at the end.
     *
     * @param operation Type of operation
     * @param service Service name
     */
    public void insert(String operation, String service) {
<span class="fc" id="L291">      Node newNode = new Node(operation, service);</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">      if (head == null) {</span>
<span class="fc" id="L294">        head = newNode;</span>
<span class="fc" id="L295">        tail = newNode;</span>
      } else {
<span class="fc" id="L297">        newNode.prev = tail;</span>
<span class="fc" id="L298">        tail.next = newNode;</span>
<span class="fc" id="L299">        tail = newNode;</span>
      }

<span class="fc" id="L302">      size++;</span>
<span class="fc" id="L303">    }</span>

    /**
     * @brief Traverses the list forward and returns all entries.
     *
     * @return List of audit log entries
     */
    public List&lt;String&gt; traverse() {
<span class="fc" id="L311">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L312">      Node curr = head;</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">      while (curr != null) {</span>
<span class="fc" id="L315">        result.add(curr.operation + &quot;: &quot; + curr.service +</span>
                   &quot; (at &quot; + new java.util.Date(curr.timestamp) + &quot;)&quot;);
<span class="fc" id="L317">        curr = curr.next;</span>
      }

<span class="fc" id="L320">      return result;</span>
    }

    /**
     * @brief Returns the number of audit entries.
     *
     * @return Size of audit log
     */
    public int size() {
<span class="fc" id="L329">      return size;</span>
    }

    /**
     * @brief Clears all audit entries.
     */
    public void clear() {
<span class="fc" id="L336">      head = null;</span>
<span class="fc" id="L337">      tail = null;</span>
<span class="fc" id="L338">      size = 0;</span>
<span class="fc" id="L339">    }</span>

    /**
     * @brief Gets the most recent audit entries.
     *
     * @param count Number of recent entries to retrieve
     * @return List of recent audit entries
     */
    public List&lt;String&gt; getRecentEntries(int count) {
<span class="fc" id="L348">      List&lt;String&gt; all = traverse();</span>
<span class="fc" id="L349">      int start = Math.max(0, all.size() - count);</span>
<span class="fc" id="L350">      return all.subList(start, all.size());</span>
    }
  }

  /**
   * @brief Audit log using XOR linked list.
   */
<span class="fc" id="L357">  private final XORLinkedList auditLog = new XORLinkedList();</span>

  /**
   * @brief Records an operation in the audit log.
   *
   * @param operation Type of operation
   * @param service Service name
   */
  public void recordAudit(String operation, String service) {
<span class="fc" id="L366">    auditLog.insert(operation, service);</span>
<span class="fc" id="L367">  }</span>

  /**
   * @brief Gets all audit log entries.
   *
   * @return List of audit entries
   */
  public List&lt;String&gt; getAuditLog() {
<span class="fc" id="L375">    return auditLog.traverse();</span>
  }

  /**
   * @brief Gets recent audit log entries.
   *
   * @param count Number of entries
   * @return List of recent entries
   */
  public List&lt;String&gt; getRecentAuditLog(int count) {
<span class="fc" id="L385">    return auditLog.getRecentEntries(count);</span>
  }

  /**
   * @brief Gets audit log size.
   *
   * @return Number of audit entries
   */
  public int getAuditLogSize() {
<span class="fc" id="L394">    return auditLog.size();</span>
  }

  /**
   * @brief Clears audit log.
   */
  public void clearAuditLog() {
<span class="fc" id="L401">    auditLog.clear();</span>
<span class="fc" id="L402">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>