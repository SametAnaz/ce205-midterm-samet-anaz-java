<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilePasswordStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">FilePasswordStorage.java</span></div><h1>FilePasswordStorage.java</h1><pre class="source lang-java linenums">package com.ucoruh.password;

import java.io.*;
import java.util.*;

/**
 * @brief Implementation of InterfacePasswordStorage using file-based storage.
 *
 * This class provides file-based operations to store, retrieve, update, and delete password entries.
 * All password data is encrypted using the master password.
 */
public class FilePasswordStorage implements InterfacePasswordStorage {
  /**
   * @brief File name used for file-based password storage.
   *
   * This static final field holds the file name where password entries are stored
   * when using a file-based storage mechanism.
   */
  private static final String FILE = &quot;passwords.txt&quot;;

  /**
   * @brief The master password used for encryption/decryption.
   */
  private final String masterPassword;

  /**
   * @brief Constructor that initializes storage with the master password.
   *
   * @param masterPassword The master password for encryption/decryption.
   */
<span class="fc" id="L31">  public FilePasswordStorage(String masterPassword) {</span>
<span class="fc" id="L32">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L33">  }</span>

  /**
   * @brief Adds a new password entry to the file-based storage.
   *
   * This method prompts the user to enter the service, username, and password, then creates a Password
   * object and appends its details to the passwords file.
   *
   * @param scanner the Scanner object used to obtain user input.
   */
  @Override
  public void add(Scanner scanner) {
<span class="fc" id="L45">    System.out.print(&quot;Service: &quot;);</span>
<span class="fc" id="L46">    String service = scanner.nextLine();</span>
<span class="fc" id="L47">    System.out.print(&quot;Username: &quot;);</span>
<span class="fc" id="L48">    String user = scanner.nextLine();</span>
<span class="fc" id="L49">    System.out.print(&quot;Password: &quot;);</span>
<span class="fc" id="L50">    String pass = scanner.nextLine();</span>
<span class="fc" id="L51">    Password p = new Password(service, user, pass);</span>
<span class="fc" id="L52">    List&lt;Password&gt; passwords = readAll();</span>
    // Check if service already exists
<span class="fc" id="L54">    boolean exists = passwords.stream()</span>
<span class="pc" id="L55">                     .anyMatch(pwd -&gt; pwd.getService().equalsIgnoreCase(service));</span>

<span class="pc bpc" id="L57" title="1 of 2 branches missed.">    if (exists) {</span>
<span class="nc" id="L58">      System.out.println(&quot;A password for this service already exists. Use update option to modify it.&quot;);</span>
<span class="nc" id="L59">      return;</span>
    }

<span class="fc" id="L62">    passwords.add(p);</span>
<span class="fc" id="L63">    writeAll(passwords);</span>
<span class="fc" id="L64">    System.out.println(&quot;Password saved successfully.&quot;);</span>
<span class="fc" id="L65">  }</span>

  /**
   * @brief Displays all stored password entries.
   *
   * This method reads all password entries from the file and prints them to the console.
   */
  @Override
  public void view() {
<span class="fc" id="L74">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L76" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L77">      System.out.println(&quot;No records found.&quot;);</span>
    } else {
<span class="fc bfc" id="L79" title="All 2 branches covered.">      for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="fc" id="L80">        System.out.println((i + 1) + &quot;. &quot; + list.get(i));</span>
      }
    }
<span class="fc" id="L83">  }</span>

  /**
   * @brief Updates an existing password entry.
   *
   * This method prompts the user for the service to update and, if found, updates its username and password.
   *
   * @param scanner the Scanner object used to obtain user input for the update.
   */
  @Override
  public void update(Scanner scanner) {
<span class="fc" id="L94">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L97">      System.out.println(&quot;No records found.&quot;);</span>
<span class="fc" id="L98">      return;</span>
    }

<span class="fc" id="L101">    System.out.print(&quot;Service to update: &quot;);</span>
<span class="fc" id="L102">    String target = scanner.nextLine();</span>
<span class="fc" id="L103">    boolean updated = false;</span>

<span class="fc bfc" id="L105" title="All 2 branches covered.">    for (Password p : list) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">      if (p.getService().equalsIgnoreCase(target)) {</span>
<span class="fc" id="L107">        System.out.print(&quot;New username (leave blank to keep current '&quot; + p.getUsername() + &quot;'): &quot;);</span>
<span class="fc" id="L108">        String username = scanner.nextLine();</span>

<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (!username.trim().isEmpty()) {</span>
<span class="fc" id="L111">          p.setUsername(username);</span>
        }

<span class="fc" id="L114">        System.out.print(&quot;New password (leave blank to keep current): &quot;);</span>
<span class="fc" id="L115">        String password = scanner.nextLine();</span>

<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (!password.trim().isEmpty()) {</span>
<span class="fc" id="L118">          p.setPassword(password);</span>
        }

<span class="fc" id="L121">        updated = true;</span>
<span class="fc" id="L122">        break;</span>
      }
<span class="fc" id="L124">    }</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">    if (updated) {</span>
<span class="fc" id="L127">      writeAll(list);</span>
<span class="fc" id="L128">      System.out.println(&quot;Password updated successfully.&quot;);</span>
    } else {
<span class="fc" id="L130">      System.out.println(&quot;Service not found.&quot;);</span>
    }
<span class="fc" id="L132">  }</span>

  /**
   * @brief Deletes a password entry from the file-based storage.
   *
   * This method prompts the user for the service name of the entry to delete and removes the entry from the file.
   *
   * @param scanner the Scanner object used to obtain user input for deletion.
   */
  @Override
  public void delete(Scanner scanner) {
<span class="fc" id="L143">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L146">      System.out.println(&quot;No records found.&quot;);</span>
<span class="fc" id="L147">      return;</span>
    }

<span class="fc" id="L150">    System.out.print(&quot;Service to delete: &quot;);</span>
<span class="fc" id="L151">    String target = scanner.nextLine();</span>
<span class="fc" id="L152">    boolean removed = list.removeIf(p -&gt; p.getService().equalsIgnoreCase(target));</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">    if (removed) {</span>
<span class="fc" id="L155">      writeAll(list);</span>
<span class="fc" id="L156">      System.out.println(&quot;Password deleted successfully.&quot;);</span>
    } else {
<span class="fc" id="L158">      System.out.println(&quot;Service not found.&quot;);</span>
    }
<span class="fc" id="L160">  }</span>

  /**
   * @brief Reads all password entries from the file.
   *
   * This method opens the file and reads each line, decrypts the data,
   * and converts it into Password objects. All valid entries are returned as a list.
   *
   * @return a List of Password objects representing the stored password entries.
   */
  @Override
  public List&lt;Password&gt; readAll() {
<span class="fc" id="L172">    List&lt;Password&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L173">    File file = new File(FILE);</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">    if (!file.exists()) {</span>
<span class="fc" id="L176">      return list;</span>
    }

<span class="fc" id="L179">    try (BufferedReader reader = new BufferedReader(new FileReader(file))) {</span>
      String line;

<span class="fc bfc" id="L182" title="All 2 branches covered.">      while ((line = reader.readLine()) != null) {</span>
        try {
          // Decrypt the line
<span class="fc" id="L185">          String decrypted = EncryptionUtil.decrypt(line, masterPassword);</span>
<span class="fc" id="L186">          String[] parts = decrypted.split(&quot;,&quot;);</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">          if (parts.length == 3) {</span>
<span class="fc" id="L189">            list.add(new Password(parts[0], parts[1], parts[2]));</span>
          }
<span class="fc" id="L191">        } catch (Exception e) {</span>
          // Skip lines that cannot be decrypted
<span class="fc" id="L193">          System.out.println(&quot;Warning: Could not decrypt a password entry.&quot;);</span>
<span class="fc" id="L194">        }</span>
      }
<span class="nc" id="L196">    } catch (IOException e) {</span>
<span class="nc" id="L197">      System.out.println(&quot;Error reading password file: &quot; + e.getMessage());</span>
<span class="fc" id="L198">    }</span>

<span class="fc" id="L200">    return list;</span>
  }

  /**
   * @brief Writes the list of password entries to the file.
   *
   * This method clears the existing content of the file and writes all password entries
   * from the provided list, encrypting each entry.
   *
   * @param list a List of Password objects to be written to the file.
   */
  @Override
  public void writeAll(List&lt;Password&gt; list) {
<span class="fc" id="L213">    try (BufferedWriter writer = new BufferedWriter(new FileWriter(FILE))) {</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">      for (Password p : list) {</span>
<span class="fc" id="L215">        String data = p.getService() + &quot;,&quot; + p.getUsername() + &quot;,&quot; + p.getPassword();</span>

        try {
          // Encrypt the data
<span class="fc" id="L219">          String encrypted = EncryptionUtil.encrypt(data, masterPassword);</span>
<span class="fc" id="L220">          writer.write(encrypted);</span>
<span class="fc" id="L221">          writer.newLine();</span>
<span class="nc" id="L222">        } catch (Exception e) {</span>
<span class="nc" id="L223">          System.out.println(&quot;Error encrypting password for &quot; + p.getService() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L224">        }</span>
<span class="fc" id="L225">      }</span>
<span class="fc" id="L226">    } catch (IOException e) {</span>
<span class="fc" id="L227">      System.out.println(&quot;Error writing to password file: &quot; + e.getMessage());</span>
<span class="fc" id="L228">    }</span>
<span class="fc" id="L229">  }</span>

  // ========== XOR LINKED LIST FOR AUDIT LOG ==========

  /**
   * @brief XOR Linked List implementation for efficient storage audit log.
   * @details Uses XOR concept to store both prev and next pointers efficiently.
   * In Java, we simulate XOR behavior since we don't have direct memory access.
   *
   * Time Complexity:
   * - insert: O(1)
   * - traverse: O(n)
   * - delete: O(n)
   *
   * Space Complexity: O(n)
   */
  public static class XORLinkedList {
    /**
     * @brief Node for XOR Linked List.
     * In a true XOR linked list, npx would contain XOR of prev and next addresses.
     * In Java, we maintain references directly but follow XOR traversal logic.
     */
    private static class Node {
      String operation; // &quot;ADD&quot;, &quot;UPDATE&quot;, &quot;DELETE&quot;, &quot;VIEW&quot;
      String service;
      long timestamp;
      Node prev; // Previous node
      Node next; // Next node

<span class="fc" id="L258">      Node(String operation, String service) {</span>
<span class="fc" id="L259">        this.operation = operation;</span>
<span class="fc" id="L260">        this.service = service;</span>
<span class="fc" id="L261">        this.timestamp = System.currentTimeMillis();</span>
<span class="fc" id="L262">        this.prev = null;</span>
<span class="fc" id="L263">        this.next = null;</span>
<span class="fc" id="L264">      }</span>
    }

    private Node head;
    private Node tail;
    private int size;

    /**
     * @brief Constructor initializes empty XOR linked list.
     */
<span class="fc" id="L274">    public XORLinkedList() {</span>
<span class="fc" id="L275">      this.head = null;</span>
<span class="fc" id="L276">      this.tail = null;</span>
<span class="fc" id="L277">      this.size = 0;</span>
<span class="fc" id="L278">    }</span>

    /**
     * @brief Inserts a new audit entry at the end.
     *
     * @param operation Type of operation
     * @param service Service name
     */
    public void insert(String operation, String service) {
<span class="fc" id="L287">      Node newNode = new Node(operation, service);</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">      if (head == null) {</span>
<span class="fc" id="L290">        head = newNode;</span>
<span class="fc" id="L291">        tail = newNode;</span>
      } else {
<span class="fc" id="L293">        newNode.prev = tail;</span>
<span class="fc" id="L294">        tail.next = newNode;</span>
<span class="fc" id="L295">        tail = newNode;</span>
      }

<span class="fc" id="L298">      size++;</span>
<span class="fc" id="L299">    }</span>

    /**
     * @brief Traverses the list forward and returns all entries.
     *
     * @return List of audit log entries
     */
    public List&lt;String&gt; traverse() {
<span class="fc" id="L307">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L308">      Node curr = head;</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">      while (curr != null) {</span>
<span class="fc" id="L311">        result.add(curr.operation + &quot;: &quot; + curr.service +</span>
                   &quot; (at &quot; + new java.util.Date(curr.timestamp) + &quot;)&quot;);
<span class="fc" id="L313">        curr = curr.next;</span>
      }

<span class="fc" id="L316">      return result;</span>
    }

    /**
     * @brief Returns the number of audit entries.
     *
     * @return Size of audit log
     */
    public int size() {
<span class="fc" id="L325">      return size;</span>
    }

    /**
     * @brief Clears all audit entries.
     */
    public void clear() {
<span class="fc" id="L332">      head = null;</span>
<span class="fc" id="L333">      tail = null;</span>
<span class="fc" id="L334">      size = 0;</span>
<span class="fc" id="L335">    }</span>

    /**
     * @brief Gets the most recent audit entries.
     *
     * @param count Number of recent entries to retrieve
     * @return List of recent audit entries
     */
    public List&lt;String&gt; getRecentEntries(int count) {
<span class="fc" id="L344">      List&lt;String&gt; all = traverse();</span>
<span class="fc" id="L345">      int start = Math.max(0, all.size() - count);</span>
<span class="fc" id="L346">      return all.subList(start, all.size());</span>
    }
  }

  /**
   * @brief Audit log using XOR linked list.
   */
<span class="fc" id="L353">  private final XORLinkedList auditLog = new XORLinkedList();</span>

  /**
   * @brief Records an operation in the audit log.
   *
   * @param operation Type of operation
   * @param service Service name
   */
  public void recordAudit(String operation, String service) {
<span class="fc" id="L362">    auditLog.insert(operation, service);</span>
<span class="fc" id="L363">  }</span>

  /**
   * @brief Gets all audit log entries.
   *
   * @return List of audit entries
   */
  public List&lt;String&gt; getAuditLog() {
<span class="fc" id="L371">    return auditLog.traverse();</span>
  }

  /**
   * @brief Gets recent audit log entries.
   *
   * @param count Number of entries
   * @return List of recent entries
   */
  public List&lt;String&gt; getRecentAuditLog(int count) {
<span class="fc" id="L381">    return auditLog.getRecentEntries(count);</span>
  }

  /**
   * @brief Gets audit log size.
   *
   * @return Number of audit entries
   */
  public int getAuditLogSize() {
<span class="fc" id="L390">    return auditLog.size();</span>
  }

  /**
   * @brief Clears audit log.
   */
  public void clearAuditLog() {
<span class="fc" id="L397">    auditLog.clear();</span>
<span class="fc" id="L398">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>