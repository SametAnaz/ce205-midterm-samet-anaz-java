<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">PasswordManager.java</span></div><h1>PasswordManager.java</h1><pre class="source lang-java linenums">package com.ucoruh.password;

import java.io.PrintStream;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;
import java.util.Stack;
import java.util.stream.Collectors;

/**
 * @brief Main class for the Password Manager application.
 *
 * Manages secure storage and retrieval of credentials using a master password.
 * Includes advanced data structures: Sparse Matrix for access pattern tracking.
 */
public class PasswordManager {
  /**
   * @brief Stores the association between account names and their corresponding passwords.
   *
   * Uses custom hash table implementation with chaining collision resolution.
   */
  private final CustomHashTable&lt;String, String&gt; credentials;

  /**
   * @brief The master password used for authentication.
   *
   * This final field stores the master password that is utilized for user authentication and securing the credentials.
   */
  private final String masterPassword;

  /**
   * @brief The storage implementation for passwords.
   */
  private final InterfacePasswordStorage storage;

  /**
   * @brief Access pattern tracking using sparse matrix.
   */
  private final AccessMatrix accessMatrix;

  /**
   * @brief Undo stack for command pattern.
   */
  private final CommandStack undoStack;

  /**
   * @brief Service dependency graph.
   */
  private final ServiceGraph serviceGraph;

  /**
   * @brief Redo stack for command pattern.
   */
  private final CommandStack redoStack;

  /**
   * @brief Pending operations queue.
   */
  private final PendingOperationsQueue operationsQueue;

  /**
   * @brief Constructor initializing the manager with a master password.
   *
   * Initializes the credentials map and loads stored credentials.
   *
   * @param masterPassword Master password used for encryption/decryption.
   */
<span class="fc" id="L78">  public PasswordManager(String masterPassword) {</span>
<span class="fc" id="L79">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L80">    this.credentials = new CustomHashTable&lt;&gt;();</span>
<span class="fc" id="L81">    this.storage = PasswordStorageFactory.create(StorageType.FILE, masterPassword);</span>
<span class="fc" id="L82">    this.accessMatrix = new AccessMatrix();</span>
<span class="fc" id="L83">    this.undoStack = new CommandStack();</span>
<span class="fc" id="L84">    this.redoStack = new CommandStack();</span>
<span class="fc" id="L85">    this.serviceGraph = new ServiceGraph();</span>
<span class="fc" id="L86">    this.operationsQueue = new PendingOperationsQueue();</span>
<span class="fc" id="L87">    loadCredentials();</span>
<span class="fc" id="L88">  }</span>

  /**
   * @brief Constructor with specified storage type.
   *
   * @param masterPassword Master password used for encryption/decryption.
   * @param storageType The type of storage to use.
   */
<span class="fc" id="L96">  public PasswordManager(String masterPassword, StorageType storageType) {</span>
<span class="fc" id="L97">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L98">    this.credentials = new CustomHashTable&lt;&gt;();</span>
<span class="fc" id="L99">    this.storage = PasswordStorageFactory.create(storageType, masterPassword);</span>
<span class="fc" id="L100">    this.accessMatrix = new AccessMatrix();</span>
<span class="fc" id="L101">    this.undoStack = new CommandStack();</span>
<span class="fc" id="L102">    this.redoStack = new CommandStack();</span>
<span class="fc" id="L103">    this.serviceGraph = new ServiceGraph();</span>
<span class="fc" id="L104">    this.operationsQueue = new PendingOperationsQueue();</span>
<span class="fc" id="L105">    loadCredentials();</span>
<span class="fc" id="L106">  }</span>

  /**
   * @brief Loads credentials from storage.
   */
  private void loadCredentials() {
<span class="fc" id="L112">    List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L113">    credentials.clear();</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">    for (Password p : passwordList) {</span>
<span class="fc" id="L116">      credentials.put(p.getService(), p.getPassword());</span>
<span class="fc" id="L117">    }</span>
<span class="fc" id="L118">  }</span>

  /**
   * @brief Adds a new credential.
   *
   * Inserts the credential for the given account into the internal storage and saves it.
   *
   * @param account Account name.
   * @param password Password for the account.
   */
  public void addCredential(String account, String password) {
    // Get old password for undo
<span class="fc" id="L130">    String oldPassword = credentials.get(account);</span>
<span class="fc" id="L131">    credentials.put(account, password);</span>
    // Create a password list and save it
<span class="fc" id="L133">    List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L134">    boolean updated = false;</span>

    // Check if the account already exists
<span class="fc bfc" id="L137" title="All 2 branches covered.">    for (Password p : passwordList) {</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">      if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L139">        p.setPassword(password);</span>
<span class="fc" id="L140">        updated = true;</span>
<span class="fc" id="L141">        break;</span>
      }
<span class="fc" id="L143">    }</span>

    // If not found, add new entry
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (!updated) {</span>
<span class="fc" id="L147">      passwordList.add(new Password(account, &quot;default_user&quot;, password));</span>
    }

<span class="fc" id="L150">    storage.writeAll(passwordList);</span>

    // Add command to undo stack
<span class="fc bfc" id="L153" title="All 2 branches covered.">    if (oldPassword == null) {</span>
      // New credential - undo should delete it
<span class="fc" id="L155">      undoStack.push(new AddCredentialCommand(account, password));</span>
    } else {
      // Update credential - undo should restore old password
<span class="fc" id="L158">      undoStack.push(new UpdateCredentialCommand(account, oldPassword, password));</span>
    }

    // Clear redo stack on new action
<span class="fc" id="L162">    redoStack.clear();</span>
<span class="fc" id="L163">  }</span>

  /**
   * @brief Retrieves a credential.
   *
   * Fetches the password associated with the specified account.
   *
   * @param account Account name.
   * @return Password if account exists; otherwise, returns null.
   */
  public String getCredential(String account) {
    // Reload credentials to ensure we have the latest
<span class="fc" id="L175">    loadCredentials();</span>
    // Record access in matrix
<span class="fc" id="L177">    recordServiceAccess(account);</span>
<span class="fc" id="L178">    return credentials.get(account);</span>
  }

  /**
   * @brief Records a service access in the access matrix.
   *
   * @param service Service name
   */
  private void recordServiceAccess(String service) {
<span class="fc" id="L187">    int hour = LocalDateTime.now().getHour();</span>
<span class="fc" id="L188">    accessMatrix.recordAccess(service, hour);</span>
<span class="fc" id="L189">  }</span>

  /**
   * @brief Gets access pattern for a specific service.
   *
   * @param service Service name
   * @return Map of hour to access count
   */
  public Map&lt;Integer, Integer&gt; getAccessPattern(String service) {
<span class="fc" id="L198">    return accessMatrix.getAccessPattern(service);</span>
  }

  /**
   * @brief Gets the most accessed services.
   *
   * @param topN Number of top services to return
   * @return List of service names sorted by access count
   */
  public List&lt;String&gt; getMostAccessedServices(int topN) {
<span class="fc" id="L208">    return accessMatrix.getMostAccessedServices(topN);</span>
  }

  /**
   * @brief Gets total access count for a service.
   *
   * @param service Service name
   * @return Total number of accesses
   */
  public int getTotalAccessCount(String service) {
<span class="fc" id="L218">    return accessMatrix.getTotalAccessCount(service);</span>
  }

  // ========== UNDO/REDO OPERATIONS ==========

  /**
   * @brief Undoes the last operation.
   *
   * @return true if undo was successful, false if nothing to undo
   */
  public boolean undo() {
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (undoStack.isEmpty()) {</span>
<span class="fc" id="L230">      return false;</span>
    }

<span class="fc" id="L233">    Command cmd = undoStack.pop();</span>
<span class="fc" id="L234">    cmd.undo();</span>
<span class="fc" id="L235">    redoStack.push(cmd);</span>
<span class="fc" id="L236">    return true;</span>
  }

  /**
   * @brief Redoes the last undone operation.
   *
   * @return true if redo was successful, false if nothing to redo
   */
  public boolean redo() {
<span class="fc bfc" id="L245" title="All 2 branches covered.">    if (redoStack.isEmpty()) {</span>
<span class="fc" id="L246">      return false;</span>
    }

<span class="fc" id="L249">    Command cmd = redoStack.pop();</span>
<span class="fc" id="L250">    cmd.execute();</span>
<span class="fc" id="L251">    undoStack.push(cmd);</span>
<span class="fc" id="L252">    return true;</span>
  }

  /**
   * @brief Checks if undo is available.
   *
   * @return true if there are operations to undo
   */
  public boolean canUndo() {
<span class="fc bfc" id="L261" title="All 2 branches covered.">    return !undoStack.isEmpty();</span>
  }

  /**
   * @brief Checks if redo is available.
   *
   * @return true if there are operations to redo
   */
  public boolean canRedo() {
<span class="fc bfc" id="L270" title="All 2 branches covered.">    return !redoStack.isEmpty();</span>
  }

  /**
   * @brief Displays the interactive menu and processes user input.
   *
   * Uses dependency injection for Scanner and PrintStream to enable unit testing.
   * Provides options to add, retrieve credentials, generate passwords, or exit.
   *
   * @param scanner The Scanner object for reading user input.
   * @param out The PrintStream object for writing output.
   */
  public void menu(Scanner scanner, PrintStream out) {
<span class="fc" id="L283">    boolean back = false;</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">    while (!back) {</span>
<span class="fc" id="L286">      out.println(&quot;\n==== PASSWORD STORAGE MENU ====&quot;);</span>
<span class="fc" id="L287">      out.println(&quot;1. Add New Password&quot;);</span>
<span class="fc" id="L288">      out.println(&quot;2. View All Passwords&quot;);</span>
<span class="fc" id="L289">      out.println(&quot;3. Update Password&quot;);</span>
<span class="fc" id="L290">      out.println(&quot;4. Delete Password&quot;);</span>
<span class="fc" id="L291">      out.println(&quot;5. Generate and Save Password&quot;);</span>
<span class="fc" id="L292">      out.println(&quot;0. Back to Main Menu&quot;);</span>
<span class="fc" id="L293">      out.print(&quot;Your choice: &quot;);</span>
<span class="fc" id="L294">      String input = scanner.nextLine();</span>

      try {
<span class="fc" id="L297">        int choice = Integer.parseInt(input);</span>

<span class="fc bfc" id="L299" title="All 7 branches covered.">        switch (choice) {</span>
          case 1:
<span class="fc" id="L301">            storage.add(scanner);</span>
<span class="fc" id="L302">            break;</span>

          case 2:
<span class="fc" id="L305">            storage.view();</span>
<span class="fc" id="L306">            break;</span>

          case 3:
<span class="fc" id="L309">            storage.update(scanner);</span>
<span class="fc" id="L310">            break;</span>

          case 4:
<span class="fc" id="L313">            storage.delete(scanner);</span>
<span class="fc" id="L314">            break;</span>

          case 5:
<span class="fc" id="L317">            generateAndSavePassword(scanner, out);</span>
<span class="fc" id="L318">            break;</span>

          case 0:
<span class="fc" id="L321">            back = true;</span>
<span class="fc" id="L322">            break;</span>

          default:
<span class="fc" id="L325">            out.println(&quot;Invalid choice.&quot;);</span>
            break;
        }

        // Reload credentials after operations
<span class="fc" id="L330">        loadCredentials();</span>
<span class="fc" id="L331">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L332">        out.println(&quot;Invalid number.&quot;);</span>
<span class="fc" id="L333">      }</span>
<span class="fc" id="L334">    }</span>
<span class="fc" id="L335">  }</span>

  /**
   * @brief Generates a new password and saves it for a service.
   *
   * @param scanner The Scanner object for user input.
   * @param out The PrintStream object for output.
   */
  private void generateAndSavePassword(Scanner scanner, PrintStream out) {
<span class="fc" id="L344">    out.print(&quot;Enter service name: &quot;);</span>
<span class="fc" id="L345">    String service = scanner.nextLine();</span>
<span class="fc" id="L346">    out.print(&quot;Enter username: &quot;);</span>
<span class="fc" id="L347">    String username = scanner.nextLine();</span>
<span class="fc" id="L348">    out.print(&quot;Enter desired password length: &quot;);</span>

    try {
<span class="fc" id="L351">      int length = Integer.parseInt(scanner.nextLine());</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">      if (length &lt;= 0) {</span>
<span class="fc" id="L354">        out.println(&quot;Password length must be greater than 0.&quot;);</span>
<span class="fc" id="L355">        return;</span>
      }

<span class="fc" id="L358">      String password = PasswordGenerator.generatePassword(length);</span>
<span class="fc" id="L359">      out.println(&quot;Generated Password: &quot; + password);</span>
<span class="fc" id="L360">      List&lt;Password&gt; passwords = storage.readAll();</span>
<span class="fc" id="L361">      boolean updated = false;</span>

      // Check if service already exists
<span class="fc bfc" id="L364" title="All 2 branches covered.">      for (Password p : passwords) {</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (p.getService().equalsIgnoreCase(service)) {</span>
<span class="fc" id="L366">          p.setUsername(username);</span>
<span class="fc" id="L367">          p.setPassword(password);</span>
<span class="fc" id="L368">          updated = true;</span>
<span class="fc" id="L369">          break;</span>
        }
<span class="fc" id="L371">      }</span>

      // If not found, add new entry
<span class="fc bfc" id="L374" title="All 2 branches covered.">      if (!updated) {</span>
<span class="fc" id="L375">        passwords.add(new Password(service, username, password));</span>
      }

<span class="fc" id="L378">      storage.writeAll(passwords);</span>
<span class="fc" id="L379">      credentials.put(service, password);</span>
<span class="fc" id="L380">      out.println(&quot;Password saved successfully.&quot;);</span>
<span class="fc" id="L381">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L382">      out.println(&quot;Invalid number.&quot;);</span>
<span class="fc" id="L383">    }</span>
<span class="fc" id="L384">  }</span>

  /**
   * @brief Runs the application using the provided Scanner and PrintStream.
   *
   * Initiates the application by requesting the master password and
   * then invoking the interactive menu.
   *
   * @param scanner Scanner for user input.
   * @param out PrintStream for output.
   */
  public static void runApp(Scanner scanner, PrintStream out) {
<span class="fc" id="L396">    out.print(&quot;Enter master password: &quot;);</span>
<span class="fc" id="L397">    String masterPwd = scanner.nextLine();</span>
<span class="fc" id="L398">    PasswordManager pm = new PasswordManager(masterPwd);</span>
<span class="fc" id="L399">    pm.menu(scanner, out);</span>
<span class="fc" id="L400">  }</span>

  /**
   * @brief Main method to launch the console application.
   *
   * Entry point of the application. Initializes input and output streams,
   * then invokes the runApp method.
   *
   * @param args Command-line arguments.
   */
  public static void main(String[] args) {
<span class="fc" id="L411">    Scanner scanner = new Scanner(System.in);</span>
<span class="fc" id="L412">    runApp(scanner, System.out);</span>
<span class="fc" id="L413">    scanner.close();</span>
<span class="fc" id="L414">  }</span>

  // ========== INNER CLASSES - DATA STRUCTURES ==========

  /**
   * @brief Sparse Matrix implementation for tracking service access patterns.
   *
   * Uses a HashMap-based approach where only non-zero entries are stored.
   * Matrix dimensions: Service (rows) Ã— Hour of Day (columns, 0-23)
   *
   * Time Complexity:
   * - recordAccess: O(1)
   * - getAccessPattern: O(1)
   * - getMostAccessedServices: O(n log n) where n is number of services
   *
   * Space Complexity: O(k) where k is number of non-zero entries
   */
  private static class AccessMatrix {
    /**
     * @brief Nested map: service -&gt; (hour -&gt; access count)
     */
    private final Map&lt;String, Map&lt;Integer, Integer&gt;&gt; matrix;

    /**
     * @brief Constructor initializes empty matrix.
     */
<span class="fc" id="L440">    public AccessMatrix() {</span>
<span class="fc" id="L441">      this.matrix = new HashMap&lt;&gt;();</span>
<span class="fc" id="L442">    }</span>

    /**
     * @brief Records an access to a service at a specific hour.
     *
     * @param service Service name
     * @param hour Hour of day (0-23)
     */
    public void recordAccess(String service, int hour) {
<span class="fc bfc" id="L451" title="All 6 branches covered.">      if (service == null || hour &lt; 0 || hour &gt; 23) {</span>
<span class="fc" id="L452">        return; // Validate input</span>
      }

<span class="fc" id="L455">      matrix.putIfAbsent(service, new HashMap&lt;&gt;());</span>
<span class="fc" id="L456">      Map&lt;Integer, Integer&gt; hourMap = matrix.get(service);</span>
<span class="fc" id="L457">      hourMap.put(hour, hourMap.getOrDefault(hour, 0) + 1);</span>
<span class="fc" id="L458">    }</span>

    /**
     * @brief Gets access pattern for a specific service.
     *
     * @param service Service name
     * @return Map of hour to access count (empty if service not found)
     */
    public Map&lt;Integer, Integer&gt; getAccessPattern(String service) {
<span class="fc" id="L467">      return matrix.getOrDefault(service, Collections.emptyMap());</span>
    }

    /**
     * @brief Gets total access count for a service across all hours.
     *
     * @param service Service name
     * @return Total access count
     */
    public int getTotalAccessCount(String service) {
<span class="fc" id="L477">      Map&lt;Integer, Integer&gt; pattern = matrix.get(service);</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">      if (pattern == null) {</span>
<span class="fc" id="L480">        return 0;</span>
      }

<span class="fc" id="L483">      return pattern.values().stream().mapToInt(Integer::intValue).sum();</span>
    }

    /**
     * @brief Gets the most accessed services sorted by total access count.
     *
     * @param topN Number of top services to return
     * @return List of service names sorted by access count (descending)
     */
    public List&lt;String&gt; getMostAccessedServices(int topN) {
<span class="fc bfc" id="L493" title="All 2 branches covered.">      if (topN &lt;= 0) {</span>
<span class="fc" id="L494">        return Collections.emptyList();</span>
      }

      // Create list of (service, totalCount) pairs
<span class="fc" id="L498">      List&lt;Map.Entry&lt;String, Integer&gt;&gt; serviceAccessList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">      for (String service : matrix.keySet()) {</span>
<span class="fc" id="L501">        int totalCount = getTotalAccessCount(service);</span>
<span class="fc" id="L502">        serviceAccessList.add(Map.entry(service, totalCount));</span>
<span class="fc" id="L503">      }</span>

      // Sort by count descending
<span class="fc" id="L506">      serviceAccessList.sort(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed());</span>
      // Return top N service names
<span class="fc" id="L508">      return serviceAccessList.stream()</span>
<span class="fc" id="L509">             .limit(topN)</span>
<span class="fc" id="L510">             .map(Map.Entry::getKey)</span>
<span class="fc" id="L511">             .collect(Collectors.toList());</span>
    }

    /**
     * @brief Gets all services tracked in the matrix.
     *
     * @return List of service names
     */
    public List&lt;String&gt; getAllServices() {
<span class="fc" id="L520">      return new ArrayList&lt;&gt;(matrix.keySet());</span>
    }

    /**
     * @brief Clears all access data.
     */
    public void clear() {
<span class="fc" id="L527">      matrix.clear();</span>
<span class="fc" id="L528">    }</span>

    /**
     * @brief Gets the number of services tracked.
     *
     * @return Number of services
     */
    public int size() {
<span class="fc" id="L536">      return matrix.size();</span>
    }
  }

  // ========== CUSTOM HASH TABLE ==========

  /**
   * @brief Custom Hash Table implementation with chaining collision resolution.
   *
   * This implementation uses separate chaining to handle collisions.
   * Provides O(1) average case for put, get, and remove operations.
   *
   * Time Complexity:
   * - put: O(1) average, O(n) worst case
   * - get: O(1) average, O(n) worst case
   * - remove: O(1) average, O(n) worst case
   * - resize: O(n) where n is number of entries
   *
   * Space Complexity: O(n) where n is number of entries
   *
   * @param &lt;K&gt; Key type
   * @param &lt;V&gt; Value type
   */
  private static class CustomHashTable&lt;K, V&gt; {
    /**
     * @brief Entry node for hash table bucket.
     */
    private static class Entry&lt;K, V&gt; {
      final K key;
      V value;
      Entry&lt;K, V&gt; next;

<span class="fc" id="L568">      Entry(K key, V value) {</span>
<span class="fc" id="L569">        this.key = key;</span>
<span class="fc" id="L570">        this.value = value;</span>
<span class="fc" id="L571">        this.next = null;</span>
<span class="fc" id="L572">      }</span>
    }

    private Entry&lt;K, V&gt;[] buckets;
    private int size;
    private int capacity;
    private static final int DEFAULT_CAPACITY = 16;
    private static final double LOAD_FACTOR_THRESHOLD = 0.75;
    private int collisionCount;

    /**
     * @brief Constructor initializes hash table with default capacity.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L586">    public CustomHashTable() {</span>
<span class="fc" id="L587">      this.capacity = DEFAULT_CAPACITY;</span>
<span class="fc" id="L588">      this.buckets = new Entry[capacity];</span>
<span class="fc" id="L589">      this.size = 0;</span>
<span class="fc" id="L590">      this.collisionCount = 0;</span>
<span class="fc" id="L591">    }</span>

    /**
     * @brief Constructor with specified initial capacity.
     *
     * @param initialCapacity Initial capacity
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L599">    public CustomHashTable(int initialCapacity) {</span>
<span class="fc" id="L600">      this.capacity = initialCapacity;</span>
<span class="fc" id="L601">      this.buckets = new Entry[capacity];</span>
<span class="fc" id="L602">      this.size = 0;</span>
<span class="fc" id="L603">      this.collisionCount = 0;</span>
<span class="fc" id="L604">    }</span>

    /**
     * @brief Computes hash for a key.
     *
     * @param key Key to hash
     * @return Hash value
     */
    private int hash(K key) {
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">      if (key == null) {</span>
<span class="nc" id="L614">        return 0;</span>
      }

<span class="fc" id="L617">      return Math.abs(key.hashCode() % capacity);</span>
    }

    /**
     * @brief Inserts or updates a key-value pair.
     *
     * @param key Key
     * @param value Value
     * @return Previous value if key existed, null otherwise
     */
    public V put(K key, V value) {
<span class="fc bfc" id="L628" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L629">        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);</span>
      }

      // Check if resize is needed
<span class="fc bfc" id="L633" title="All 2 branches covered.">      if (getLoadFactor() &gt;= LOAD_FACTOR_THRESHOLD) {</span>
<span class="fc" id="L634">        resize();</span>
      }

<span class="fc" id="L637">      int index = hash(key);</span>
<span class="fc" id="L638">      Entry&lt;K, V&gt; entry = buckets[index];</span>

      // Check if key already exists
<span class="fc bfc" id="L641" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (entry.key.equals(key)) {</span>
<span class="fc" id="L643">          V oldValue = entry.value;</span>
<span class="fc" id="L644">          entry.value = value;</span>
<span class="fc" id="L645">          return oldValue;</span>
        }

<span class="fc" id="L648">        entry = entry.next;</span>
      }

      // Add new entry at the beginning of the chain
<span class="fc" id="L652">      Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value);</span>
<span class="fc" id="L653">      newEntry.next = buckets[index];</span>

      // Track collision
<span class="fc bfc" id="L656" title="All 2 branches covered.">      if (buckets[index] != null) {</span>
<span class="fc" id="L657">        collisionCount++;</span>
      }

<span class="fc" id="L660">      buckets[index] = newEntry;</span>
<span class="fc" id="L661">      size++;</span>
<span class="fc" id="L662">      return null;</span>
    }

    /**
     * @brief Retrieves value for a key.
     *
     * @param key Key to look up
     * @return Value if found, null otherwise
     */
    public V get(K key) {
<span class="fc bfc" id="L672" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L673">        return null;</span>
      }

<span class="fc" id="L676">      int index = hash(key);</span>
<span class="fc" id="L677">      Entry&lt;K, V&gt; entry = buckets[index];</span>

<span class="fc bfc" id="L679" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (entry.key.equals(key)) {</span>
<span class="fc" id="L681">          return entry.value;</span>
        }

<span class="fc" id="L684">        entry = entry.next;</span>
      }

<span class="fc" id="L687">      return null;</span>
    }

    /**
     * @brief Removes a key-value pair.
     *
     * @param key Key to remove
     * @return Value if key existed, null otherwise
     */
    public V remove(K key) {
<span class="fc bfc" id="L697" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L698">        return null;</span>
      }

<span class="fc" id="L701">      int index = hash(key);</span>
<span class="fc" id="L702">      Entry&lt;K, V&gt; entry = buckets[index];</span>
<span class="fc" id="L703">      Entry&lt;K, V&gt; prev = null;</span>

<span class="fc bfc" id="L705" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">        if (entry.key.equals(key)) {</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">          if (prev == null) {</span>
<span class="fc" id="L708">            buckets[index] = entry.next;</span>
          } else {
<span class="nc" id="L710">            prev.next = entry.next;</span>
          }

<span class="fc" id="L713">          size--;</span>
<span class="fc" id="L714">          return entry.value;</span>
        }

<span class="nc" id="L717">        prev = entry;</span>
<span class="nc" id="L718">        entry = entry.next;</span>
      }

<span class="fc" id="L721">      return null;</span>
    }

    /**
     * @brief Checks if key exists.
     *
     * @param key Key to check
     * @return true if key exists
     */
    public boolean containsKey(K key) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">      return get(key) != null;</span>
    }

    /**
     * @brief Returns number of entries.
     *
     * @return Size
     */
    public int size() {
<span class="fc" id="L740">      return size;</span>
    }

    /**
     * @brief Checks if hash table is empty.
     *
     * @return true if empty
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L749" title="All 2 branches covered.">      return size == 0;</span>
    }

    /**
     * @brief Clears all entries.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void clear() {
<span class="fc" id="L757">      buckets = new Entry[capacity];</span>
<span class="fc" id="L758">      size = 0;</span>
<span class="fc" id="L759">      collisionCount = 0;</span>
<span class="fc" id="L760">    }</span>

    /**
     * @brief Gets current load factor.
     *
     * @return Load factor
     */
    public double getLoadFactor() {
<span class="fc" id="L768">      return (double) size / capacity;</span>
    }

    /**
     * @brief Gets total collision count.
     *
     * @return Collision count
     */
    public int getCollisionCount() {
<span class="fc" id="L777">      return collisionCount;</span>
    }

    /**
     * @brief Gets all keys.
     *
     * @return List of keys
     */
    public List&lt;K&gt; keySet() {
<span class="fc" id="L786">      List&lt;K&gt; keys = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L788" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : buckets) {</span>
<span class="fc" id="L789">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L791" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L792">          keys.add(entry.key);</span>
<span class="fc" id="L793">          entry = entry.next;</span>
        }
      }

<span class="fc" id="L797">      return keys;</span>
    }

    /**
     * @brief Gets all values.
     *
     * @return List of values
     */
    public List&lt;V&gt; values() {
<span class="fc" id="L806">      List&lt;V&gt; vals = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : buckets) {</span>
<span class="fc" id="L809">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L811" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L812">          vals.add(entry.value);</span>
<span class="fc" id="L813">          entry = entry.next;</span>
        }
      }

<span class="fc" id="L817">      return vals;</span>
    }

    /**
     * @brief Resizes the hash table when load factor exceeds threshold.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void resize() {
<span class="fc" id="L825">      int newCapacity = capacity * 2;</span>
<span class="fc" id="L826">      Entry&lt;K, V&gt;[] oldBuckets = buckets;</span>
<span class="fc" id="L827">      buckets = new Entry[newCapacity];</span>
<span class="fc" id="L828">      capacity = newCapacity;</span>
<span class="fc" id="L829">      size = 0;</span>
<span class="fc" id="L830">      collisionCount = 0;</span>

      // Rehash all entries
<span class="fc bfc" id="L833" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : oldBuckets) {</span>
<span class="fc" id="L834">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L836" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L837">          put(entry.key, entry.value);</span>
<span class="fc" id="L838">          entry = entry.next;</span>
        }
      }
<span class="fc" id="L841">    }</span>
  }

  // ========== HEAP SORT IMPLEMENTATION ==========

  /**
   * @brief Service usage data for sorting.
   */
  private static class ServiceUsage implements Comparable&lt;ServiceUsage&gt; {
    private final String service;
    private final int usageCount;

<span class="fc" id="L853">    public ServiceUsage(String service, int usageCount) {</span>
<span class="fc" id="L854">      this.service = service;</span>
<span class="fc" id="L855">      this.usageCount = usageCount;</span>
<span class="fc" id="L856">    }</span>

    public String getService() {
<span class="fc" id="L859">      return service;</span>
    }

    public int getUsageCount() {
<span class="fc" id="L863">      return usageCount;</span>
    }

    @Override
    public int compareTo(ServiceUsage other) {
      // Natural order: ascending by usage count
<span class="fc" id="L869">      return Integer.compare(this.usageCount, other.usageCount);</span>
    }
  }

  /**
   * @brief Sorts service usage data using heap sort algorithm.
   *
   * Time Complexity: O(n log n)
   * Space Complexity: O(1) - in-place sorting
   *
   * @param arr Array to sort
   */
  private void heapSort(ServiceUsage[] arr) {
<span class="fc" id="L882">    int n = arr.length;</span>

    // Build max heap
<span class="fc bfc" id="L885" title="All 2 branches covered.">    for (int i = n / 2 - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L886">      heapify(arr, n, i);</span>
    }

    // Extract elements from heap one by one
<span class="fc bfc" id="L890" title="All 2 branches covered.">    for (int i = n - 1; i &gt; 0; i--) {</span>
      // Move current root to end
<span class="fc" id="L892">      ServiceUsage temp = arr[0];</span>
<span class="fc" id="L893">      arr[0] = arr[i];</span>
<span class="fc" id="L894">      arr[i] = temp;</span>
      // Heapify the reduced heap
<span class="fc" id="L896">      heapify(arr, i, 0);</span>
    }
<span class="fc" id="L898">  }</span>

  /**
   * @brief Maintains heap property for a subtree.
   *
   * @param arr Array representing heap
   * @param n Size of heap
   * @param i Root index of subtree
   */
  private void heapify(ServiceUsage[] arr, int n, int i) {
<span class="fc" id="L908">    int largest = i;</span>
<span class="fc" id="L909">    int left = 2 * i + 1;</span>
<span class="fc" id="L910">    int right = 2 * i + 2;</span>

    // Check if left child is larger than root
<span class="fc bfc" id="L913" title="All 4 branches covered.">    if (left &lt; n &amp;&amp; arr[left].compareTo(arr[largest]) &gt; 0) {</span>
<span class="fc" id="L914">      largest = left;</span>
    }

    // Check if right child is larger than current largest
<span class="fc bfc" id="L918" title="All 4 branches covered.">    if (right &lt; n &amp;&amp; arr[right].compareTo(arr[largest]) &gt; 0) {</span>
<span class="fc" id="L919">      largest = right;</span>
    }

    // If largest is not root
<span class="fc bfc" id="L923" title="All 2 branches covered.">    if (largest != i) {</span>
<span class="fc" id="L924">      ServiceUsage swap = arr[i];</span>
<span class="fc" id="L925">      arr[i] = arr[largest];</span>
<span class="fc" id="L926">      arr[largest] = swap;</span>
      // Recursively heapify the affected subtree
<span class="fc" id="L928">      heapify(arr, n, largest);</span>
    }
<span class="fc" id="L930">  }</span>

  /**
   * @brief Gets most used services sorted by usage count using heap sort.
   *
   * Combines access matrix data with heap sort for efficient ranking.
   *
   * @return List of services sorted by usage count
   */
  public List&lt;String&gt; getMostUsedServicesByHeapSort() {
<span class="fc" id="L940">    List&lt;String&gt; services = accessMatrix.getAllServices();</span>

<span class="fc bfc" id="L942" title="All 2 branches covered.">    if (services.isEmpty()) {</span>
<span class="fc" id="L943">      return new ArrayList&lt;&gt;();</span>
    }

    // Create array of service usage
<span class="fc" id="L947">    ServiceUsage[] usageArray = new ServiceUsage[services.size()];</span>

<span class="fc bfc" id="L949" title="All 2 branches covered.">    for (int i = 0; i &lt; services.size(); i++) {</span>
<span class="fc" id="L950">      String service = services.get(i);</span>
<span class="fc" id="L951">      int count = accessMatrix.getTotalAccessCount(service);</span>
<span class="fc" id="L952">      usageArray[i] = new ServiceUsage(service, count);</span>
    }

    // Sort using heap sort (ascending)
<span class="fc" id="L956">    heapSort(usageArray);</span>
    // Reverse to get descending order (most used first)
<span class="fc" id="L958">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L960" title="All 2 branches covered.">    for (int i = usageArray.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L961">      ServiceUsage usage = usageArray[i];</span>
<span class="fc" id="L962">      result.add(usage.getService() + &quot; (&quot; + usage.getUsageCount() + &quot; accesses)&quot;);</span>
    }

<span class="fc" id="L965">    return result;</span>
  }

  // ========== COMMAND PATTERN FOR UNDO/REDO ==========

  /**
   * @brief Command interface for undo/redo operations.
   */
  private interface Command {
    void execute();
    void undo();
  }

  /**
   * @brief Command for adding a new credential.
   */
  private class AddCredentialCommand implements Command {
    private final String account;
    private final String password;

<span class="fc" id="L985">    AddCredentialCommand(String account, String password) {</span>
<span class="fc" id="L986">      this.account = account;</span>
<span class="fc" id="L987">      this.password = password;</span>
<span class="fc" id="L988">    }</span>

    @Override
    public void execute() {
<span class="fc" id="L992">      credentials.put(account, password);</span>
<span class="fc" id="L993">      List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L994">      passwordList.add(new Password(account, &quot;default_user&quot;, password));</span>
<span class="fc" id="L995">      storage.writeAll(passwordList);</span>
<span class="fc" id="L996">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L1000">      credentials.remove(account);</span>
<span class="fc" id="L1001">      List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L1002">      passwordList.removeIf(p -&gt; p.getService().equalsIgnoreCase(account));</span>
<span class="fc" id="L1003">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1004">    }</span>
  }

  /**
   * @brief Command for updating an existing credential.
   */
  private class UpdateCredentialCommand implements Command {
    private final String account;
    private final String oldPassword;
    private final String newPassword;

<span class="fc" id="L1015">    UpdateCredentialCommand(String account, String oldPassword, String newPassword) {</span>
<span class="fc" id="L1016">      this.account = account;</span>
<span class="fc" id="L1017">      this.oldPassword = oldPassword;</span>
<span class="fc" id="L1018">      this.newPassword = newPassword;</span>
<span class="fc" id="L1019">    }</span>

    @Override
    public void execute() {
<span class="fc" id="L1023">      credentials.put(account, newPassword);</span>
<span class="fc" id="L1024">      List&lt;Password&gt; passwordList = storage.readAll();</span>

<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">      for (Password p : passwordList) {</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L1028">          p.setPassword(newPassword);</span>
<span class="fc" id="L1029">          break;</span>
        }
<span class="nc" id="L1031">      }</span>

<span class="fc" id="L1033">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1034">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L1038">      credentials.put(account, oldPassword);</span>
<span class="fc" id="L1039">      List&lt;Password&gt; passwordList = storage.readAll();</span>

<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">      for (Password p : passwordList) {</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">        if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L1043">          p.setPassword(oldPassword);</span>
<span class="fc" id="L1044">          break;</span>
        }
<span class="nc" id="L1046">      }</span>

<span class="fc" id="L1048">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1049">    }</span>
  }

  /**
   * @brief Stack implementation for command history.
   *
   * Uses linked list approach for O(1) push/pop operations.
   *
   * Time Complexity:
   * - push: O(1)
   * - pop: O(1)
   * - peek: O(1)
   * - isEmpty: O(1)
   *
   * Space Complexity: O(n) where n is number of commands
   */
  private static class CommandStack {
    /**
     * @brief Node for stack implementation.
     */
    private static class Node {
      Command command;
      Node next;

<span class="fc" id="L1073">      Node(Command command) {</span>
<span class="fc" id="L1074">        this.command = command;</span>
<span class="fc" id="L1075">        this.next = null;</span>
<span class="fc" id="L1076">      }</span>
    }

    private Node top;
    private int size;

    /**
     * @brief Constructor initializes empty stack.
     */
<span class="fc" id="L1085">    public CommandStack() {</span>
<span class="fc" id="L1086">      this.top = null;</span>
<span class="fc" id="L1087">      this.size = 0;</span>
<span class="fc" id="L1088">    }</span>

    /**
     * @brief Pushes a command onto the stack.
     *
     * @param command Command to push
     */
    public void push(Command command) {
<span class="fc" id="L1096">      Node newNode = new Node(command);</span>
<span class="fc" id="L1097">      newNode.next = top;</span>
<span class="fc" id="L1098">      top = newNode;</span>
<span class="fc" id="L1099">      size++;</span>
<span class="fc" id="L1100">    }</span>

    /**
     * @brief Pops a command from the stack.
     *
     * @return Command from top of stack, or null if empty
     */
    public Command pop() {
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">      if (isEmpty()) {</span>
<span class="nc" id="L1109">        return null;</span>
      }

<span class="fc" id="L1112">      Command command = top.command;</span>
<span class="fc" id="L1113">      top = top.next;</span>
<span class="fc" id="L1114">      size--;</span>
<span class="fc" id="L1115">      return command;</span>
    }

    /**
     * @brief Peeks at the top command without removing it.
     *
     * @return Command from top of stack, or null if empty
     */
    public Command peek() {
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">      return isEmpty() ? null : top.command;</span>
    }

    /**
     * @brief Checks if stack is empty.
     *
     * @return true if stack has no elements
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1133" title="All 2 branches covered.">      return top == null;</span>
    }

    /**
     * @brief Gets the size of the stack.
     *
     * @return Number of commands in stack
     */
    public int size() {
<span class="fc" id="L1142">      return size;</span>
    }

    /**
     * @brief Clears all commands from the stack.
     */
    public void clear() {
<span class="fc" id="L1149">      top = null;</span>
<span class="fc" id="L1150">      size = 0;</span>
<span class="fc" id="L1151">    }</span>
  }

  // ========== SERVICE DEPENDENCY GRAPH (BFS, DFS, SCC) ==========

  /**
   * @brief Graph data structure for tracking service dependencies.
   * @details Implements directed graph with BFS, DFS, and Strongly Connected Components (Kosaraju's algorithm).
   *
   * Time Complexity:
   * - addEdge: O(1)
   * - BFS: O(V + E)
   * - DFS: O(V + E)
   * - SCC: O(V + E)
   *
   * Space Complexity: O(V + E)
   */
  public static class ServiceGraph {
    private final Map&lt;String, List&lt;String&gt;&gt; adjacencyList;
    private final Map&lt;String, List&lt;String&gt;&gt; reverseAdjacencyList;

    /**
     * @brief Constructor initializes empty graph.
     */
<span class="fc" id="L1175">    public ServiceGraph() {</span>
<span class="fc" id="L1176">      this.adjacencyList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1177">      this.reverseAdjacencyList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1178">    }</span>

    /**
     * @brief Adds a directed edge from service1 to service2.
     * @details Represents that service1 depends on service2.
     *
     * @param service1 Source service
     * @param service2 Destination service
     */
    public void addEdge(String service1, String service2) {
<span class="fc" id="L1188">      adjacencyList.putIfAbsent(service1, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1189">      adjacencyList.putIfAbsent(service2, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1190">      adjacencyList.get(service1).add(service2);</span>
      // Build reverse graph for SCC
<span class="fc" id="L1192">      reverseAdjacencyList.putIfAbsent(service1, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1193">      reverseAdjacencyList.putIfAbsent(service2, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1194">      reverseAdjacencyList.get(service2).add(service1);</span>
<span class="fc" id="L1195">    }</span>

    /**
     * @brief Breadth-First Search traversal starting from a service.
     * @details Returns list of services reachable from start in BFS order.
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @param start Starting service
     * @return List of services in BFS order
     */
    public List&lt;String&gt; bfs(String start) {
<span class="fc bfc" id="L1208" title="All 2 branches covered.">      if (!adjacencyList.containsKey(start)) {</span>
<span class="fc" id="L1209">        return new ArrayList&lt;&gt;();</span>
      }

<span class="fc" id="L1212">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1213">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1214">      Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1215">      queue.offer(start);</span>
<span class="fc" id="L1216">      visited.add(start);</span>

<span class="fc bfc" id="L1218" title="All 2 branches covered.">      while (!queue.isEmpty()) {</span>
<span class="fc" id="L1219">        String current = queue.poll();</span>
<span class="fc" id="L1220">        result.add(current);</span>
<span class="fc" id="L1221">        List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">        if (neighbors != null) {</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">          for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">            if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1226">              visited.add(neighbor);</span>
<span class="fc" id="L1227">              queue.offer(neighbor);</span>
            }
<span class="fc" id="L1229">          }</span>
        }
<span class="fc" id="L1231">      }</span>

<span class="fc" id="L1233">      return result;</span>
    }

    /**
     * @brief Depth-First Search traversal starting from a service.
     * @details Returns list of services reachable from start in DFS order.
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @param start Starting service
     * @return List of services in DFS order
     */
    public List&lt;String&gt; dfs(String start) {
<span class="fc bfc" id="L1247" title="All 2 branches covered.">      if (!adjacencyList.containsKey(start)) {</span>
<span class="fc" id="L1248">        return new ArrayList&lt;&gt;();</span>
      }

<span class="fc" id="L1251">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1252">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1253">      dfsHelper(start, visited, result);</span>
<span class="fc" id="L1254">      return result;</span>
    }

    /**
     * @brief Helper method for DFS traversal.
     *
     * @param current Current service being visited
     * @param visited Set of visited services
     * @param result List to store DFS order
     */
    private void dfsHelper(String current, Set&lt;String&gt; visited, List&lt;String&gt; result) {
<span class="fc" id="L1265">      visited.add(current);</span>
<span class="fc" id="L1266">      result.add(current);</span>
<span class="fc" id="L1267">      List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1272">            dfsHelper(neighbor, visited, result);</span>
          }
<span class="fc" id="L1274">        }</span>
      }
<span class="fc" id="L1276">    }</span>

    /**
     * @brief Finds all Strongly Connected Components using Kosaraju's algorithm.
     * @details A SCC is a maximal set of vertices where each vertex is reachable from every other.
     *
     * Algorithm:
     * 1. Perform DFS on original graph to get finish times
     * 2. Perform DFS on reversed graph in decreasing finish time order
     * 3. Each DFS tree in step 2 is a SCC
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @return List of SCCs, each SCC is a list of services
     */
    public List&lt;List&lt;String&gt;&gt; findStronglyConnectedComponents() {
<span class="fc" id="L1293">      List&lt;List&lt;String&gt;&gt; sccs = new ArrayList&lt;&gt;();</span>
      // Step 1: Get finish times using DFS
<span class="fc" id="L1295">      Stack&lt;String&gt; finishStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L1296">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L1298" title="All 2 branches covered.">      for (String service : adjacencyList.keySet()) {</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">        if (!visited.contains(service)) {</span>
<span class="fc" id="L1300">          fillFinishStack(service, visited, finishStack);</span>
        }
<span class="fc" id="L1302">      }</span>

      // Step 2: Process vertices in decreasing finish time order on reversed graph
<span class="fc" id="L1305">      visited.clear();</span>

<span class="fc bfc" id="L1307" title="All 2 branches covered.">      while (!finishStack.isEmpty()) {</span>
<span class="fc" id="L1308">        String service = finishStack.pop();</span>

<span class="fc bfc" id="L1310" title="All 2 branches covered.">        if (!visited.contains(service)) {</span>
<span class="fc" id="L1311">          List&lt;String&gt; scc = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1312">          dfsReverse(service, visited, scc);</span>
<span class="fc" id="L1313">          sccs.add(scc);</span>
        }
<span class="fc" id="L1315">      }</span>

<span class="fc" id="L1317">      return sccs;</span>
    }

    /**
     * @brief Fills stack with services in order of finish time.
     *
     * @param current Current service
     * @param visited Set of visited services
     * @param finishStack Stack to store finish order
     */
    private void fillFinishStack(String current, Set&lt;String&gt; visited, Stack&lt;String&gt; finishStack) {
<span class="fc" id="L1328">      visited.add(current);</span>
<span class="fc" id="L1329">      List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1334">            fillFinishStack(neighbor, visited, finishStack);</span>
          }
<span class="fc" id="L1336">        }</span>
      }

<span class="fc" id="L1339">      finishStack.push(current);</span>
<span class="fc" id="L1340">    }</span>

    /**
     * @brief DFS on reversed graph to find a SCC.
     *
     * @param current Current service
     * @param visited Set of visited services
     * @param scc List to store current SCC
     */
    private void dfsReverse(String current, Set&lt;String&gt; visited, List&lt;String&gt; scc) {
<span class="fc" id="L1350">      visited.add(current);</span>
<span class="fc" id="L1351">      scc.add(current);</span>
<span class="fc" id="L1352">      List&lt;String&gt; neighbors = reverseAdjacencyList.get(current);</span>

<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1357">            dfsReverse(neighbor, visited, scc);</span>
          }
<span class="fc" id="L1359">        }</span>
      }
<span class="fc" id="L1361">    }</span>

    /**
     * @brief Gets all services in the graph.
     *
     * @return Set of all service names
     */
    public Set&lt;String&gt; getAllServices() {
<span class="fc" id="L1369">      return new HashSet&lt;&gt;(adjacencyList.keySet());</span>
    }

    /**
     * @brief Gets neighbors of a service.
     *
     * @param service Service name
     * @return List of neighboring services
     */
    public List&lt;String&gt; getNeighbors(String service) {
<span class="fc" id="L1379">      List&lt;String&gt; neighbors = adjacencyList.get(service);</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">      return neighbors != null ? new ArrayList&lt;&gt;(neighbors) : new ArrayList&lt;&gt;();</span>
    }

    /**
     * @brief Checks if graph contains a service.
     *
     * @param service Service name
     * @return true if service exists in graph
     */
    public boolean containsService(String service) {
<span class="fc" id="L1390">      return adjacencyList.containsKey(service);</span>
    }

    /**
     * @brief Clears the graph.
     */
    public void clear() {
<span class="fc" id="L1397">      adjacencyList.clear();</span>
<span class="fc" id="L1398">      reverseAdjacencyList.clear();</span>
<span class="fc" id="L1399">    }</span>
  }

  /**
   * @brief Analyzes service dependencies and returns related services.
   * @details Uses BFS to find all services reachable from the given service.
   *
   * @param service Service name
   * @return List of related services
   */
  public List&lt;String&gt; getRelatedServices(String service) {
<span class="fc" id="L1410">    return serviceGraph.bfs(service);</span>
  }

  /**
   * @brief Adds a dependency relationship between two services.
   *
   * @param service1 Source service
   * @param service2 Dependent service
   */
  public void addServiceDependency(String service1, String service2) {
<span class="fc" id="L1420">    serviceGraph.addEdge(service1, service2);</span>
<span class="fc" id="L1421">  }</span>

  /**
   * @brief Gets all strongly connected components in service dependencies.
   *
   * @return List of SCCs
   */
  public List&lt;List&lt;String&gt;&gt; getServiceClusters() {
<span class="fc" id="L1429">    return serviceGraph.findStronglyConnectedComponents();</span>
  }

  /**
   * @brief Gets the service dependency graph.
   *
   * @return ServiceGraph instance
   */
  public ServiceGraph getServiceGraph() {
<span class="fc" id="L1438">    return serviceGraph;</span>
  }

  /**
   * @brief Queues a pending operation.
   *
   * @param operation Operation description
   */
  public void queueOperation(String operation) {
<span class="fc" id="L1447">    operationsQueue.enqueue(operation);</span>
<span class="fc" id="L1448">  }</span>

  /**
   * @brief Processes all pending operations.
   *
   * @return List of processed operations
   */
  public List&lt;String&gt; processPendingOperations() {
<span class="fc" id="L1456">    List&lt;String&gt; processed = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1458" title="All 2 branches covered.">    while (!operationsQueue.isEmpty()) {</span>
<span class="fc" id="L1459">      processed.add(operationsQueue.dequeue());</span>
    }

<span class="fc" id="L1462">    return processed;</span>
  }

  /**
   * @brief Gets the count of pending operations.
   *
   * @return Number of pending operations
   */
  public int getPendingOperationsCount() {
<span class="fc" id="L1471">    return operationsQueue.size();</span>
  }

  /**
   * @brief Peeks at the next pending operation without removing it.
   *
   * @return Next operation or null if queue is empty
   */
  public String peekNextOperation() {
<span class="fc" id="L1480">    return operationsQueue.peek();</span>
  }

  /**
   * @brief Gets the pending operations queue.
   *
   * @return PendingOperationsQueue instance
   */
  public PendingOperationsQueue getOperationsQueue() {
<span class="fc" id="L1489">    return operationsQueue;</span>
  }

  /**
   * @brief Custom Queue implementation using linked nodes.
   *
   * Implements FIFO (First-In-First-Out) data structure for pending operations.
   */
  public static class PendingOperationsQueue {
    /**
     * @brief Node class for queue elements.
     */
    private static class Node {
      String operation;
      Node next;

<span class="fc" id="L1505">      Node(String operation) {</span>
<span class="fc" id="L1506">        this.operation = operation;</span>
<span class="fc" id="L1507">        this.next = null;</span>
<span class="fc" id="L1508">      }</span>
    }

    private Node front;  // Front of queue (dequeue from here)
    private Node rear;   // Rear of queue (enqueue to here)
    private int size;

    /**
     * @brief Constructor initializing empty queue.
     */
<span class="fc" id="L1518">    public PendingOperationsQueue() {</span>
<span class="fc" id="L1519">      this.front = null;</span>
<span class="fc" id="L1520">      this.rear = null;</span>
<span class="fc" id="L1521">      this.size = 0;</span>
<span class="fc" id="L1522">    }</span>

    /**
     * @brief Adds an operation to the rear of the queue.
     *
     * Time complexity: O(1)
     *
     * @param operation Operation to enqueue
     */
    public void enqueue(String operation) {
<span class="fc" id="L1532">      Node newNode = new Node(operation);</span>

<span class="fc bfc" id="L1534" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1535">        front = newNode;</span>
<span class="fc" id="L1536">        rear = newNode;</span>
      } else {
<span class="fc" id="L1538">        rear.next = newNode;</span>
<span class="fc" id="L1539">        rear = newNode;</span>
      }

<span class="fc" id="L1542">      size++;</span>
<span class="fc" id="L1543">    }</span>

    /**
     * @brief Removes and returns the operation from the front of the queue.
     *
     * Time complexity: O(1)
     *
     * @return Front operation, or null if queue is empty
     */
    public String dequeue() {
<span class="fc bfc" id="L1553" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1554">        return null;</span>
      }

<span class="fc" id="L1557">      String operation = front.operation;</span>
<span class="fc" id="L1558">      front = front.next;</span>

<span class="fc bfc" id="L1560" title="All 2 branches covered.">      if (front == null) {</span>
<span class="fc" id="L1561">        rear = null;  // Queue is now empty</span>
      }

<span class="fc" id="L1564">      size--;</span>
<span class="fc" id="L1565">      return operation;</span>
    }

    /**
     * @brief Returns the operation at the front without removing it.
     *
     * Time complexity: O(1)
     *
     * @return Front operation, or null if queue is empty
     */
    public String peek() {
<span class="fc bfc" id="L1576" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1577">        return null;</span>
      }

<span class="fc" id="L1580">      return front.operation;</span>
    }

    /**
     * @brief Checks if the queue is empty.
     *
     * Time complexity: O(1)
     *
     * @return true if queue is empty, false otherwise
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1591" title="All 2 branches covered.">      return size == 0;</span>
    }

    /**
     * @brief Gets the current size of the queue.
     *
     * Time complexity: O(1)
     *
     * @return Number of operations in the queue
     */
    public int size() {
<span class="fc" id="L1602">      return size;</span>
    }

    /**
     * @brief Clears all operations from the queue.
     *
     * Time complexity: O(1)
     */
    public void clear() {
<span class="fc" id="L1611">      front = null;</span>
<span class="fc" id="L1612">      rear = null;</span>
<span class="fc" id="L1613">      size = 0;</span>
<span class="fc" id="L1614">    }</span>

    /**
     * @brief Gets all operations as a list without removing them.
     *
     * Time complexity: O(n)
     *
     * @return List of all operations in FIFO order
     */
    public List&lt;String&gt; toList() {
<span class="fc" id="L1624">      List&lt;String&gt; operations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1625">      Node current = front;</span>

<span class="fc bfc" id="L1627" title="All 2 branches covered.">      while (current != null) {</span>
<span class="fc" id="L1628">        operations.add(current.operation);</span>
<span class="fc" id="L1629">        current = current.next;</span>
      }

<span class="fc" id="L1632">      return operations;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>