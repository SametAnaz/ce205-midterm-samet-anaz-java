<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">PasswordManager.java</span></div><h1>PasswordManager.java</h1><pre class="source lang-java linenums">package com.ucoruh.password;

import java.io.PrintStream;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;
import java.util.Stack;
import java.util.stream.Collectors;

/**
 * @file PasswordManager.java
 * @class PasswordManager
 * @brief Main class for the Password Manager application.
 * @author Password Manager Team
 * @version 1.0
 *
 * Manages secure storage and retrieval of credentials using a master password.
 * Includes advanced data structures: Sparse Matrix for access pattern tracking.
 */
public class PasswordManager {
  /**
   * @brief Stores the association between account names and their corresponding passwords.
   *
   * Uses custom hash table implementation with chaining collision resolution.
   */
  private final CustomHashTable&lt;String, String&gt; credentials;

  /**
   * @brief The master password used for authentication.
   *
   * This final field stores the master password that is utilized for user authentication and securing the credentials.
   */
  private final String masterPassword;

  /**
   * @brief The storage implementation for passwords.
   */
  private final InterfacePasswordStorage storage;

  /**
   * @brief Access pattern tracking using sparse matrix.
   */
  private final AccessMatrix accessMatrix;

  /**
   * @brief Undo stack for command pattern.
   */
  private final CommandStack undoStack;

  /**
   * @brief Service dependency graph.
   */
  private final ServiceGraph serviceGraph;

  /**
   * @brief Redo stack for command pattern.
   */
  private final CommandStack redoStack;

  /**
   * @brief Pending operations queue.
   */
  private final PendingOperationsQueue operationsQueue;

  /**
   * @brief Constructor initializing the manager with a master password.
   *
   * Initializes the credentials map and loads stored credentials.
   *
   * @param masterPassword Master password used for encryption/decryption.
   */
<span class="fc" id="L82">  public PasswordManager(String masterPassword) {</span>
<span class="fc" id="L83">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L84">    this.credentials = new CustomHashTable&lt;&gt;();</span>
<span class="fc" id="L85">    this.storage = PasswordStorageFactory.create(StorageType.FILE, masterPassword);</span>
<span class="fc" id="L86">    this.accessMatrix = new AccessMatrix();</span>
<span class="fc" id="L87">    this.undoStack = new CommandStack();</span>
<span class="fc" id="L88">    this.redoStack = new CommandStack();</span>
<span class="fc" id="L89">    this.serviceGraph = new ServiceGraph();</span>
<span class="fc" id="L90">    this.operationsQueue = new PendingOperationsQueue();</span>
<span class="fc" id="L91">    loadCredentials();</span>
<span class="fc" id="L92">  }</span>

  /**
   * @brief Constructor with specified storage type.
   *
   * @param masterPassword Master password used for encryption/decryption.
   * @param storageType The type of storage to use.
   */
<span class="fc" id="L100">  public PasswordManager(String masterPassword, StorageType storageType) {</span>
<span class="fc" id="L101">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L102">    this.credentials = new CustomHashTable&lt;&gt;();</span>
<span class="fc" id="L103">    this.storage = PasswordStorageFactory.create(storageType, masterPassword);</span>
<span class="fc" id="L104">    this.accessMatrix = new AccessMatrix();</span>
<span class="fc" id="L105">    this.undoStack = new CommandStack();</span>
<span class="fc" id="L106">    this.redoStack = new CommandStack();</span>
<span class="fc" id="L107">    this.serviceGraph = new ServiceGraph();</span>
<span class="fc" id="L108">    this.operationsQueue = new PendingOperationsQueue();</span>
<span class="fc" id="L109">    loadCredentials();</span>
<span class="fc" id="L110">  }</span>

  /**
   * @brief Loads credentials from storage.
   */
  private void loadCredentials() {
<span class="fc" id="L116">    List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L117">    credentials.clear();</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">    for (Password p : passwordList) {</span>
<span class="fc" id="L120">      credentials.put(p.getService(), p.getPassword());</span>
<span class="fc" id="L121">    }</span>
<span class="fc" id="L122">  }</span>

  /**
   * @brief Adds a new credential.
   *
   * Inserts the credential for the given account into the internal storage and saves it.
   *
   * @param account Account name.
   * @param password Password for the account.
   */
  public void addCredential(String account, String password) {
    // Get old password for undo
<span class="fc" id="L134">    String oldPassword = credentials.get(account);</span>
<span class="fc" id="L135">    credentials.put(account, password);</span>
    // Create a password list and save it
<span class="fc" id="L137">    List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L138">    boolean updated = false;</span>

    // Check if the account already exists
<span class="fc bfc" id="L141" title="All 2 branches covered.">    for (Password p : passwordList) {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">      if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L143">        p.setPassword(password);</span>
<span class="fc" id="L144">        updated = true;</span>
<span class="fc" id="L145">        break;</span>
      }
<span class="fc" id="L147">    }</span>

    // If not found, add new entry
<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (!updated) {</span>
<span class="fc" id="L151">      passwordList.add(new Password(account, &quot;default_user&quot;, password));</span>
    }

<span class="fc" id="L154">    storage.writeAll(passwordList);</span>

    // Add command to undo stack
<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (oldPassword == null) {</span>
      // New credential - undo should delete it
<span class="fc" id="L159">      undoStack.push(new AddCredentialCommand(account, password));</span>
    } else {
      // Update credential - undo should restore old password
<span class="fc" id="L162">      undoStack.push(new UpdateCredentialCommand(account, oldPassword, password));</span>
    }

    // Clear redo stack on new action
<span class="fc" id="L166">    redoStack.clear();</span>
<span class="fc" id="L167">  }</span>

  /**
   * @brief Retrieves a credential.
   *
   * Fetches the password associated with the specified account.
   *
   * @param account Account name.
   * @return Password if account exists; otherwise, returns null.
   */
  public String getCredential(String account) {
    // Reload credentials to ensure we have the latest
<span class="fc" id="L179">    loadCredentials();</span>
    // Record access in matrix
<span class="fc" id="L181">    recordServiceAccess(account);</span>
<span class="fc" id="L182">    return credentials.get(account);</span>
  }

  /**
   * @brief Records a service access in the access matrix.
   *
   * @param service Service name
   */
  private void recordServiceAccess(String service) {
<span class="fc" id="L191">    int hour = LocalDateTime.now().getHour();</span>
<span class="fc" id="L192">    accessMatrix.recordAccess(service, hour);</span>
<span class="fc" id="L193">  }</span>

  /**
   * @brief Gets access pattern for a specific service.
   *
   * @param service Service name
   * @return Map of hour to access count
   */
  public Map&lt;Integer, Integer&gt; getAccessPattern(String service) {
<span class="fc" id="L202">    return accessMatrix.getAccessPattern(service);</span>
  }

  /**
   * @brief Gets the most accessed services.
   *
   * @param topN Number of top services to return
   * @return List of service names sorted by access count
   */
  public List&lt;String&gt; getMostAccessedServices(int topN) {
<span class="fc" id="L212">    return accessMatrix.getMostAccessedServices(topN);</span>
  }

  /**
   * @brief Gets total access count for a service.
   *
   * @param service Service name
   * @return Total number of accesses
   */
  public int getTotalAccessCount(String service) {
<span class="fc" id="L222">    return accessMatrix.getTotalAccessCount(service);</span>
  }

  // ========== UNDO/REDO OPERATIONS ==========

  /**
   * @brief Undoes the last operation.
   *
   * @return true if undo was successful, false if nothing to undo
   */
  public boolean undo() {
<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (undoStack.isEmpty()) {</span>
<span class="fc" id="L234">      return false;</span>
    }

<span class="fc" id="L237">    Command cmd = undoStack.pop();</span>
<span class="fc" id="L238">    cmd.undo();</span>
<span class="fc" id="L239">    redoStack.push(cmd);</span>
<span class="fc" id="L240">    return true;</span>
  }

  /**
   * @brief Redoes the last undone operation.
   *
   * @return true if redo was successful, false if nothing to redo
   */
  public boolean redo() {
<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (redoStack.isEmpty()) {</span>
<span class="fc" id="L250">      return false;</span>
    }

<span class="fc" id="L253">    Command cmd = redoStack.pop();</span>
<span class="fc" id="L254">    cmd.execute();</span>
<span class="fc" id="L255">    undoStack.push(cmd);</span>
<span class="fc" id="L256">    return true;</span>
  }

  /**
   * @brief Checks if undo is available.
   *
   * @return true if there are operations to undo
   */
  public boolean canUndo() {
<span class="fc bfc" id="L265" title="All 2 branches covered.">    return !undoStack.isEmpty();</span>
  }

  /**
   * @brief Checks if redo is available.
   *
   * @return true if there are operations to redo
   */
  public boolean canRedo() {
<span class="fc bfc" id="L274" title="All 2 branches covered.">    return !redoStack.isEmpty();</span>
  }

  /**
   * @brief Displays the interactive menu and processes user input.
   *
   * Uses dependency injection for Scanner and PrintStream to enable unit testing.
   * Provides options to add, retrieve credentials, generate passwords, or exit.
   *
   * @param scanner The Scanner object for reading user input.
   * @param out The PrintStream object for writing output.
   */
  public void menu(Scanner scanner, PrintStream out) {
<span class="fc" id="L287">    boolean back = false;</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">    while (!back) {</span>
<span class="fc" id="L290">      out.println(&quot;\n==== PASSWORD STORAGE MENU ====&quot;);</span>
<span class="fc" id="L291">      out.println(&quot;1. Add New Password&quot;);</span>
<span class="fc" id="L292">      out.println(&quot;2. View All Passwords&quot;);</span>
<span class="fc" id="L293">      out.println(&quot;3. Update Password&quot;);</span>
<span class="fc" id="L294">      out.println(&quot;4. Delete Password&quot;);</span>
<span class="fc" id="L295">      out.println(&quot;5. Generate and Save Password&quot;);</span>
<span class="fc" id="L296">      out.println(&quot;0. Back to Main Menu&quot;);</span>
<span class="fc" id="L297">      out.print(&quot;Your choice: &quot;);</span>
<span class="fc" id="L298">      String input = scanner.nextLine();</span>

      try {
<span class="fc" id="L301">        int choice = Integer.parseInt(input);</span>

<span class="fc bfc" id="L303" title="All 7 branches covered.">        switch (choice) {</span>
          case 1:
<span class="fc" id="L305">            storage.add(scanner);</span>
<span class="fc" id="L306">            break;</span>

          case 2:
<span class="fc" id="L309">            storage.view();</span>
<span class="fc" id="L310">            break;</span>

          case 3:
<span class="fc" id="L313">            storage.update(scanner);</span>
<span class="fc" id="L314">            break;</span>

          case 4:
<span class="fc" id="L317">            storage.delete(scanner);</span>
<span class="fc" id="L318">            break;</span>

          case 5:
<span class="fc" id="L321">            generateAndSavePassword(scanner, out);</span>
<span class="fc" id="L322">            break;</span>

          case 0:
<span class="fc" id="L325">            back = true;</span>
<span class="fc" id="L326">            break;</span>

          default:
<span class="fc" id="L329">            out.println(&quot;Invalid choice.&quot;);</span>
            break;
        }

        // Reload credentials after operations
<span class="fc" id="L334">        loadCredentials();</span>
<span class="fc" id="L335">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L336">        out.println(&quot;Invalid number.&quot;);</span>
<span class="fc" id="L337">      }</span>
<span class="fc" id="L338">    }</span>
<span class="fc" id="L339">  }</span>

  /**
   * @brief Generates a new password and saves it for a service.
   *
   * @param scanner The Scanner object for user input.
   * @param out The PrintStream object for output.
   */
  private void generateAndSavePassword(Scanner scanner, PrintStream out) {
<span class="fc" id="L348">    out.print(&quot;Enter service name: &quot;);</span>
<span class="fc" id="L349">    String service = scanner.nextLine();</span>
<span class="fc" id="L350">    out.print(&quot;Enter username: &quot;);</span>
<span class="fc" id="L351">    String username = scanner.nextLine();</span>
<span class="fc" id="L352">    out.print(&quot;Enter desired password length: &quot;);</span>

    try {
<span class="fc" id="L355">      int length = Integer.parseInt(scanner.nextLine());</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">      if (length &lt;= 0) {</span>
<span class="fc" id="L358">        out.println(&quot;Password length must be greater than 0.&quot;);</span>
<span class="fc" id="L359">        return;</span>
      }

<span class="fc" id="L362">      String password = PasswordGenerator.generatePassword(length);</span>
<span class="fc" id="L363">      out.println(&quot;Generated Password: &quot; + password);</span>
<span class="fc" id="L364">      List&lt;Password&gt; passwords = storage.readAll();</span>
<span class="fc" id="L365">      boolean updated = false;</span>

      // Check if service already exists
<span class="fc bfc" id="L368" title="All 2 branches covered.">      for (Password p : passwords) {</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (p.getService().equalsIgnoreCase(service)) {</span>
<span class="fc" id="L370">          p.setUsername(username);</span>
<span class="fc" id="L371">          p.setPassword(password);</span>
<span class="fc" id="L372">          updated = true;</span>
<span class="fc" id="L373">          break;</span>
        }
<span class="fc" id="L375">      }</span>

      // If not found, add new entry
<span class="fc bfc" id="L378" title="All 2 branches covered.">      if (!updated) {</span>
<span class="fc" id="L379">        passwords.add(new Password(service, username, password));</span>
      }

<span class="fc" id="L382">      storage.writeAll(passwords);</span>
<span class="fc" id="L383">      credentials.put(service, password);</span>
<span class="fc" id="L384">      out.println(&quot;Password saved successfully.&quot;);</span>
<span class="fc" id="L385">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L386">      out.println(&quot;Invalid number.&quot;);</span>
<span class="fc" id="L387">    }</span>
<span class="fc" id="L388">  }</span>

  /**
   * @brief Runs the application using the provided Scanner and PrintStream.
   *
   * Initiates the application by requesting the master password and
   * then invoking the interactive menu.
   *
   * @param scanner Scanner for user input.
   * @param out PrintStream for output.
   */
  public static void runApp(Scanner scanner, PrintStream out) {
<span class="fc" id="L400">    out.print(&quot;Enter master password: &quot;);</span>
<span class="fc" id="L401">    String masterPwd = scanner.nextLine();</span>
<span class="fc" id="L402">    PasswordManager pm = new PasswordManager(masterPwd);</span>
<span class="fc" id="L403">    pm.menu(scanner, out);</span>
<span class="fc" id="L404">  }</span>

  /**
   * @brief Main method to launch the console application.
   *
   * Entry point of the application. Initializes input and output streams,
   * then invokes the runApp method.
   *
   * @param args Command-line arguments.
   */
  public static void main(String[] args) {
<span class="fc" id="L415">    Scanner scanner = new Scanner(System.in);</span>
<span class="fc" id="L416">    runApp(scanner, System.out);</span>
<span class="fc" id="L417">    scanner.close();</span>
<span class="fc" id="L418">  }</span>

  // ========== INNER CLASSES - DATA STRUCTURES ==========

  /**
   * @brief Sparse Matrix implementation for tracking service access patterns.
   *
   * Uses a HashMap-based approach where only non-zero entries are stored.
   * Matrix dimensions: Service (rows) Ã— Hour of Day (columns, 0-23)
   *
   * Time Complexity:
   * - recordAccess: O(1)
   * - getAccessPattern: O(1)
   * - getMostAccessedServices: O(n log n) where n is number of services
   *
   * Space Complexity: O(k) where k is number of non-zero entries
   */
  private static class AccessMatrix {
    /**
     * @brief Nested map: service -&gt; (hour -&gt; access count)
     */
    private final Map&lt;String, Map&lt;Integer, Integer&gt;&gt; matrix;

    /**
     * @brief Constructor initializes empty matrix.
     */
<span class="fc" id="L444">    public AccessMatrix() {</span>
<span class="fc" id="L445">      this.matrix = new HashMap&lt;&gt;();</span>
<span class="fc" id="L446">    }</span>

    /**
     * @brief Records an access to a service at a specific hour.
     *
     * @param service Service name
     * @param hour Hour of day (0-23)
     */
    public void recordAccess(String service, int hour) {
<span class="fc bfc" id="L455" title="All 6 branches covered.">      if (service == null || hour &lt; 0 || hour &gt; 23) {</span>
<span class="fc" id="L456">        return; // Validate input</span>
      }

<span class="fc" id="L459">      matrix.putIfAbsent(service, new HashMap&lt;&gt;());</span>
<span class="fc" id="L460">      Map&lt;Integer, Integer&gt; hourMap = matrix.get(service);</span>
<span class="fc" id="L461">      hourMap.put(hour, hourMap.getOrDefault(hour, 0) + 1);</span>
<span class="fc" id="L462">    }</span>

    /**
     * @brief Gets access pattern for a specific service.
     *
     * @param service Service name
     * @return Map of hour to access count (empty if service not found)
     */
    public Map&lt;Integer, Integer&gt; getAccessPattern(String service) {
<span class="fc" id="L471">      return matrix.getOrDefault(service, Collections.emptyMap());</span>
    }

    /**
     * @brief Gets total access count for a service across all hours.
     *
     * @param service Service name
     * @return Total access count
     */
    public int getTotalAccessCount(String service) {
<span class="fc" id="L481">      Map&lt;Integer, Integer&gt; pattern = matrix.get(service);</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">      if (pattern == null) {</span>
<span class="fc" id="L484">        return 0;</span>
      }

<span class="fc" id="L487">      return pattern.values().stream().mapToInt(Integer::intValue).sum();</span>
    }

    /**
     * @brief Gets the most accessed services sorted by total access count.
     *
     * @param topN Number of top services to return
     * @return List of service names sorted by access count (descending)
     */
    public List&lt;String&gt; getMostAccessedServices(int topN) {
<span class="fc bfc" id="L497" title="All 2 branches covered.">      if (topN &lt;= 0) {</span>
<span class="fc" id="L498">        return Collections.emptyList();</span>
      }

      // Create list of (service, totalCount) pairs
<span class="fc" id="L502">      List&lt;Map.Entry&lt;String, Integer&gt;&gt; serviceAccessList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">      for (String service : matrix.keySet()) {</span>
<span class="fc" id="L505">        int totalCount = getTotalAccessCount(service);</span>
<span class="fc" id="L506">        serviceAccessList.add(Map.entry(service, totalCount));</span>
<span class="fc" id="L507">      }</span>

      // Sort by count descending
<span class="fc" id="L510">      serviceAccessList.sort(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed());</span>
      // Return top N service names
<span class="fc" id="L512">      return serviceAccessList.stream()</span>
<span class="fc" id="L513">             .limit(topN)</span>
<span class="fc" id="L514">             .map(Map.Entry::getKey)</span>
<span class="fc" id="L515">             .collect(Collectors.toList());</span>
    }

    /**
     * @brief Gets all services tracked in the matrix.
     *
     * @return List of service names
     */
    public List&lt;String&gt; getAllServices() {
<span class="fc" id="L524">      return new ArrayList&lt;&gt;(matrix.keySet());</span>
    }

    /**
     * @brief Clears all access data.
     */
    public void clear() {
<span class="fc" id="L531">      matrix.clear();</span>
<span class="fc" id="L532">    }</span>

    /**
     * @brief Gets the number of services tracked.
     *
     * @return Number of services
     */
    public int size() {
<span class="fc" id="L540">      return matrix.size();</span>
    }
  }

  // ========== CUSTOM HASH TABLE ==========

  /**
   * @brief Custom Hash Table implementation with chaining collision resolution.
   *
   * This implementation uses separate chaining to handle collisions.
   * Provides O(1) average case for put, get, and remove operations.
   *
   * Time Complexity:
   * - put: O(1) average, O(n) worst case
   * - get: O(1) average, O(n) worst case
   * - remove: O(1) average, O(n) worst case
   * - resize: O(n) where n is number of entries
   *
   * Space Complexity: O(n) where n is number of entries
   *
   * @param &lt;K&gt; Key type
   * @param &lt;V&gt; Value type
   */
  private static class CustomHashTable&lt;K, V&gt; {
    /**
     * @brief Entry node for hash table bucket.
     */
    private static class Entry&lt;K, V&gt; {
      /** @brief The key of this entry */
      final K key;
      /** @brief The value associated with the key */
      V value;
      /** @brief Reference to the next entry in the chain */
      Entry&lt;K, V&gt; next;

      /**
       * @brief Constructs an entry with given key and value.
       * @param key The key
       * @param value The value
       */
<span class="fc" id="L580">      Entry(K key, V value) {</span>
<span class="fc" id="L581">        this.key = key;</span>
<span class="fc" id="L582">        this.value = value;</span>
<span class="fc" id="L583">        this.next = null;</span>
<span class="fc" id="L584">      }</span>
    }

    /** @brief Array of buckets for the hash table */
    private Entry&lt;K, V&gt;[] buckets;
    /** @brief Current number of entries in the hash table */
    private int size;
    /** @brief Current capacity of the hash table */
    private int capacity;
    /** @brief Default initial capacity */
    private static final int DEFAULT_CAPACITY = 16;
    /** @brief Load factor threshold for resizing */
    private static final double LOAD_FACTOR_THRESHOLD = 0.75;
    /** @brief Count of collisions that have occurred */
    private int collisionCount;

    /**
     * @brief Constructor initializes hash table with default capacity.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L604">    public CustomHashTable() {</span>
<span class="fc" id="L605">      this.capacity = DEFAULT_CAPACITY;</span>
<span class="fc" id="L606">      this.buckets = new Entry[capacity];</span>
<span class="fc" id="L607">      this.size = 0;</span>
<span class="fc" id="L608">      this.collisionCount = 0;</span>
<span class="fc" id="L609">    }</span>

    /**
     * @brief Constructor with specified initial capacity.
     *
     * @param initialCapacity Initial capacity
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L617">    public CustomHashTable(int initialCapacity) {</span>
<span class="fc" id="L618">      this.capacity = initialCapacity;</span>
<span class="fc" id="L619">      this.buckets = new Entry[capacity];</span>
<span class="fc" id="L620">      this.size = 0;</span>
<span class="fc" id="L621">      this.collisionCount = 0;</span>
<span class="fc" id="L622">    }</span>

    /**
     * @brief Computes hash for a key.
     *
     * @param key Key to hash
     * @return Hash value
     */
    private int hash(K key) {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">      if (key == null) {</span>
<span class="nc" id="L632">        return 0;</span>
      }

<span class="fc" id="L635">      return Math.abs(key.hashCode() % capacity);</span>
    }

    /**
     * @brief Inserts or updates a key-value pair.
     *
     * @param key Key
     * @param value Value
     * @return Previous value if key existed, null otherwise
     */
    public V put(K key, V value) {
<span class="fc bfc" id="L646" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L647">        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);</span>
      }

      // Check if resize is needed
<span class="fc bfc" id="L651" title="All 2 branches covered.">      if (getLoadFactor() &gt;= LOAD_FACTOR_THRESHOLD) {</span>
<span class="fc" id="L652">        resize();</span>
      }

<span class="fc" id="L655">      int index = hash(key);</span>
<span class="fc" id="L656">      Entry&lt;K, V&gt; entry = buckets[index];</span>

      // Check if key already exists
<span class="fc bfc" id="L659" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (entry.key.equals(key)) {</span>
<span class="fc" id="L661">          V oldValue = entry.value;</span>
<span class="fc" id="L662">          entry.value = value;</span>
<span class="fc" id="L663">          return oldValue;</span>
        }

<span class="fc" id="L666">        entry = entry.next;</span>
      }

      // Add new entry at the beginning of the chain
<span class="fc" id="L670">      Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value);</span>
<span class="fc" id="L671">      newEntry.next = buckets[index];</span>

      // Track collision
<span class="fc bfc" id="L674" title="All 2 branches covered.">      if (buckets[index] != null) {</span>
<span class="fc" id="L675">        collisionCount++;</span>
      }

<span class="fc" id="L678">      buckets[index] = newEntry;</span>
<span class="fc" id="L679">      size++;</span>
<span class="fc" id="L680">      return null;</span>
    }

    /**
     * @brief Retrieves value for a key.
     *
     * @param key Key to look up
     * @return Value if found, null otherwise
     */
    public V get(K key) {
<span class="fc bfc" id="L690" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L691">        return null;</span>
      }

<span class="fc" id="L694">      int index = hash(key);</span>
<span class="fc" id="L695">      Entry&lt;K, V&gt; entry = buckets[index];</span>

<span class="fc bfc" id="L697" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (entry.key.equals(key)) {</span>
<span class="fc" id="L699">          return entry.value;</span>
        }

<span class="fc" id="L702">        entry = entry.next;</span>
      }

<span class="fc" id="L705">      return null;</span>
    }

    /**
     * @brief Removes a key-value pair.
     *
     * @param key Key to remove
     * @return Value if key existed, null otherwise
     */
    public V remove(K key) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L716">        return null;</span>
      }

<span class="fc" id="L719">      int index = hash(key);</span>
<span class="fc" id="L720">      Entry&lt;K, V&gt; entry = buckets[index];</span>
<span class="fc" id="L721">      Entry&lt;K, V&gt; prev = null;</span>

<span class="fc bfc" id="L723" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">        if (entry.key.equals(key)) {</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">          if (prev == null) {</span>
<span class="fc" id="L726">            buckets[index] = entry.next;</span>
          } else {
<span class="nc" id="L728">            prev.next = entry.next;</span>
          }

<span class="fc" id="L731">          size--;</span>
<span class="fc" id="L732">          return entry.value;</span>
        }

<span class="nc" id="L735">        prev = entry;</span>
<span class="nc" id="L736">        entry = entry.next;</span>
      }

<span class="fc" id="L739">      return null;</span>
    }

    /**
     * @brief Checks if key exists.
     *
     * @param key Key to check
     * @return true if key exists
     */
    public boolean containsKey(K key) {
<span class="fc bfc" id="L749" title="All 2 branches covered.">      return get(key) != null;</span>
    }

    /**
     * @brief Returns number of entries.
     *
     * @return Size
     */
    public int size() {
<span class="fc" id="L758">      return size;</span>
    }

    /**
     * @brief Checks if hash table is empty.
     *
     * @return true if empty
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L767" title="All 2 branches covered.">      return size == 0;</span>
    }

    /**
     * @brief Clears all entries.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void clear() {
<span class="fc" id="L775">      buckets = new Entry[capacity];</span>
<span class="fc" id="L776">      size = 0;</span>
<span class="fc" id="L777">      collisionCount = 0;</span>
<span class="fc" id="L778">    }</span>

    /**
     * @brief Gets current load factor.
     *
     * @return Load factor
     */
    public double getLoadFactor() {
<span class="fc" id="L786">      return (double) size / capacity;</span>
    }

    /**
     * @brief Gets total collision count.
     *
     * @return Collision count
     */
    public int getCollisionCount() {
<span class="fc" id="L795">      return collisionCount;</span>
    }

    /**
     * @brief Gets all keys.
     *
     * @return List of keys
     */
    public List&lt;K&gt; keySet() {
<span class="fc" id="L804">      List&lt;K&gt; keys = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L806" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : buckets) {</span>
<span class="fc" id="L807">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L809" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L810">          keys.add(entry.key);</span>
<span class="fc" id="L811">          entry = entry.next;</span>
        }
      }

<span class="fc" id="L815">      return keys;</span>
    }

    /**
     * @brief Gets all values.
     *
     * @return List of values
     */
    public List&lt;V&gt; values() {
<span class="fc" id="L824">      List&lt;V&gt; vals = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L826" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : buckets) {</span>
<span class="fc" id="L827">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L829" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L830">          vals.add(entry.value);</span>
<span class="fc" id="L831">          entry = entry.next;</span>
        }
      }

<span class="fc" id="L835">      return vals;</span>
    }

    /**
     * @brief Resizes the hash table when load factor exceeds threshold.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void resize() {
<span class="fc" id="L843">      int newCapacity = capacity * 2;</span>
<span class="fc" id="L844">      Entry&lt;K, V&gt;[] oldBuckets = buckets;</span>
<span class="fc" id="L845">      buckets = new Entry[newCapacity];</span>
<span class="fc" id="L846">      capacity = newCapacity;</span>
<span class="fc" id="L847">      size = 0;</span>
<span class="fc" id="L848">      collisionCount = 0;</span>

      // Rehash all entries
<span class="fc bfc" id="L851" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : oldBuckets) {</span>
<span class="fc" id="L852">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L854" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L855">          put(entry.key, entry.value);</span>
<span class="fc" id="L856">          entry = entry.next;</span>
        }
      }
<span class="fc" id="L859">    }</span>
  }

  // ========== HEAP SORT IMPLEMENTATION ==========

  /**
   * @brief Service usage data for sorting.
   */
  private static class ServiceUsage implements Comparable&lt;ServiceUsage&gt; {
    /** @brief The service name */
    private final String service;
    /** @brief The usage count for this service */
    private final int usageCount;

    /**
     * @brief Constructs a ServiceUsage object.
     * @param service The service name
     * @param usageCount The usage count
     */
<span class="fc" id="L878">    public ServiceUsage(String service, int usageCount) {</span>
<span class="fc" id="L879">      this.service = service;</span>
<span class="fc" id="L880">      this.usageCount = usageCount;</span>
<span class="fc" id="L881">    }</span>

    /**
     * @brief Gets the service name.
     * @return The service name
     */
    public String getService() {
<span class="fc" id="L888">      return service;</span>
    }

    /**
     * @brief Gets the usage count.
     * @return The usage count
     */
    public int getUsageCount() {
<span class="fc" id="L896">      return usageCount;</span>
    }

    @Override
    public int compareTo(ServiceUsage other) {
      // Natural order: ascending by usage count
<span class="fc" id="L902">      return Integer.compare(this.usageCount, other.usageCount);</span>
    }
  }

  /**
   * @brief Sorts service usage data using heap sort algorithm.
   *
   * Time Complexity: O(n log n)
   * Space Complexity: O(1) - in-place sorting
   *
   * @param arr Array to sort
   */
  private void heapSort(ServiceUsage[] arr) {
<span class="fc" id="L915">    int n = arr.length;</span>

    // Build max heap
<span class="fc bfc" id="L918" title="All 2 branches covered.">    for (int i = n / 2 - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L919">      heapify(arr, n, i);</span>
    }

    // Extract elements from heap one by one
<span class="fc bfc" id="L923" title="All 2 branches covered.">    for (int i = n - 1; i &gt; 0; i--) {</span>
      // Move current root to end
<span class="fc" id="L925">      ServiceUsage temp = arr[0];</span>
<span class="fc" id="L926">      arr[0] = arr[i];</span>
<span class="fc" id="L927">      arr[i] = temp;</span>
      // Heapify the reduced heap
<span class="fc" id="L929">      heapify(arr, i, 0);</span>
    }
<span class="fc" id="L931">  }</span>

  /**
   * @brief Maintains heap property for a subtree.
   *
   * @param arr Array representing heap
   * @param n Size of heap
   * @param i Root index of subtree
   */
  private void heapify(ServiceUsage[] arr, int n, int i) {
<span class="fc" id="L941">    int largest = i;</span>
<span class="fc" id="L942">    int left = 2 * i + 1;</span>
<span class="fc" id="L943">    int right = 2 * i + 2;</span>

    // Check if left child is larger than root
<span class="fc bfc" id="L946" title="All 4 branches covered.">    if (left &lt; n &amp;&amp; arr[left].compareTo(arr[largest]) &gt; 0) {</span>
<span class="fc" id="L947">      largest = left;</span>
    }

    // Check if right child is larger than current largest
<span class="fc bfc" id="L951" title="All 4 branches covered.">    if (right &lt; n &amp;&amp; arr[right].compareTo(arr[largest]) &gt; 0) {</span>
<span class="fc" id="L952">      largest = right;</span>
    }

    // If largest is not root
<span class="fc bfc" id="L956" title="All 2 branches covered.">    if (largest != i) {</span>
<span class="fc" id="L957">      ServiceUsage swap = arr[i];</span>
<span class="fc" id="L958">      arr[i] = arr[largest];</span>
<span class="fc" id="L959">      arr[largest] = swap;</span>
      // Recursively heapify the affected subtree
<span class="fc" id="L961">      heapify(arr, n, largest);</span>
    }
<span class="fc" id="L963">  }</span>

  /**
   * @brief Gets most used services sorted by usage count using heap sort.
   *
   * Combines access matrix data with heap sort for efficient ranking.
   *
   * @return List of services sorted by usage count
   */
  public List&lt;String&gt; getMostUsedServicesByHeapSort() {
<span class="fc" id="L973">    List&lt;String&gt; services = accessMatrix.getAllServices();</span>

<span class="fc bfc" id="L975" title="All 2 branches covered.">    if (services.isEmpty()) {</span>
<span class="fc" id="L976">      return new ArrayList&lt;&gt;();</span>
    }

    // Create array of service usage
<span class="fc" id="L980">    ServiceUsage[] usageArray = new ServiceUsage[services.size()];</span>

<span class="fc bfc" id="L982" title="All 2 branches covered.">    for (int i = 0; i &lt; services.size(); i++) {</span>
<span class="fc" id="L983">      String service = services.get(i);</span>
<span class="fc" id="L984">      int count = accessMatrix.getTotalAccessCount(service);</span>
<span class="fc" id="L985">      usageArray[i] = new ServiceUsage(service, count);</span>
    }

    // Sort using heap sort (ascending)
<span class="fc" id="L989">    heapSort(usageArray);</span>
    // Reverse to get descending order (most used first)
<span class="fc" id="L991">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L993" title="All 2 branches covered.">    for (int i = usageArray.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L994">      ServiceUsage usage = usageArray[i];</span>
<span class="fc" id="L995">      result.add(usage.getService() + &quot; (&quot; + usage.getUsageCount() + &quot; accesses)&quot;);</span>
    }

<span class="fc" id="L998">    return result;</span>
  }

  // ========== COMMAND PATTERN FOR UNDO/REDO ==========

  /**
   * @brief Command interface for undo/redo operations.
   */
  private interface Command {
    void execute();
    void undo();
  }

  /**
   * @brief Command for adding a new credential.
   */
  private class AddCredentialCommand implements Command {
    private final String account;
    private final String password;

<span class="fc" id="L1018">    AddCredentialCommand(String account, String password) {</span>
<span class="fc" id="L1019">      this.account = account;</span>
<span class="fc" id="L1020">      this.password = password;</span>
<span class="fc" id="L1021">    }</span>

    @Override
    public void execute() {
<span class="fc" id="L1025">      credentials.put(account, password);</span>
<span class="fc" id="L1026">      List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L1027">      passwordList.add(new Password(account, &quot;default_user&quot;, password));</span>
<span class="fc" id="L1028">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1029">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L1033">      credentials.remove(account);</span>
<span class="fc" id="L1034">      List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L1035">      passwordList.removeIf(p -&gt; p.getService().equalsIgnoreCase(account));</span>
<span class="fc" id="L1036">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1037">    }</span>
  }

  /**
   * @brief Command for updating an existing credential.
   */
  private class UpdateCredentialCommand implements Command {
    private final String account;
    private final String oldPassword;
    private final String newPassword;

<span class="fc" id="L1048">    UpdateCredentialCommand(String account, String oldPassword, String newPassword) {</span>
<span class="fc" id="L1049">      this.account = account;</span>
<span class="fc" id="L1050">      this.oldPassword = oldPassword;</span>
<span class="fc" id="L1051">      this.newPassword = newPassword;</span>
<span class="fc" id="L1052">    }</span>

    @Override
    public void execute() {
<span class="fc" id="L1056">      credentials.put(account, newPassword);</span>
<span class="fc" id="L1057">      List&lt;Password&gt; passwordList = storage.readAll();</span>

<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">      for (Password p : passwordList) {</span>
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">        if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L1061">          p.setPassword(newPassword);</span>
<span class="fc" id="L1062">          break;</span>
        }
<span class="nc" id="L1064">      }</span>

<span class="fc" id="L1066">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1067">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L1071">      credentials.put(account, oldPassword);</span>
<span class="fc" id="L1072">      List&lt;Password&gt; passwordList = storage.readAll();</span>

<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">      for (Password p : passwordList) {</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L1076">          p.setPassword(oldPassword);</span>
<span class="fc" id="L1077">          break;</span>
        }
<span class="nc" id="L1079">      }</span>

<span class="fc" id="L1081">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1082">    }</span>
  }

  /**
   * @brief Stack implementation for command history.
   *
   * Uses linked list approach for O(1) push/pop operations.
   *
   * Time Complexity:
   * - push: O(1)
   * - pop: O(1)
   * - peek: O(1)
   * - isEmpty: O(1)
   *
   * Space Complexity: O(n) where n is number of commands
   */
  private static class CommandStack {
    /**
     * @brief Node for stack implementation.
     */
    private static class Node {
      /** @brief The command stored in this node */
      Command command;
      /** @brief Reference to the next node */
      Node next;

      /**
       * @brief Constructs a node with the given command.
       * @param command The command to store
       */
<span class="fc" id="L1112">      Node(Command command) {</span>
<span class="fc" id="L1113">        this.command = command;</span>
<span class="fc" id="L1114">        this.next = null;</span>
<span class="fc" id="L1115">      }</span>
    }

    /** @brief Reference to the top of the stack */
    private Node top;
    /** @brief Current number of elements in the stack */
    private int size;

    /**
     * @brief Constructor initializes empty stack.
     */
<span class="fc" id="L1126">    public CommandStack() {</span>
<span class="fc" id="L1127">      this.top = null;</span>
<span class="fc" id="L1128">      this.size = 0;</span>
<span class="fc" id="L1129">    }</span>

    /**
     * @brief Pushes a command onto the stack.
     *
     * @param command Command to push
     */
    public void push(Command command) {
<span class="fc" id="L1137">      Node newNode = new Node(command);</span>
<span class="fc" id="L1138">      newNode.next = top;</span>
<span class="fc" id="L1139">      top = newNode;</span>
<span class="fc" id="L1140">      size++;</span>
<span class="fc" id="L1141">    }</span>

    /**
     * @brief Pops a command from the stack.
     *
     * @return Command from top of stack, or null if empty
     */
    public Command pop() {
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">      if (isEmpty()) {</span>
<span class="nc" id="L1150">        return null;</span>
      }

<span class="fc" id="L1153">      Command command = top.command;</span>
<span class="fc" id="L1154">      top = top.next;</span>
<span class="fc" id="L1155">      size--;</span>
<span class="fc" id="L1156">      return command;</span>
    }

    /**
     * @brief Peeks at the top command without removing it.
     *
     * @return Command from top of stack, or null if empty
     */
    public Command peek() {
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">      return isEmpty() ? null : top.command;</span>
    }

    /**
     * @brief Checks if stack is empty.
     *
     * @return true if stack has no elements
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1174" title="All 2 branches covered.">      return top == null;</span>
    }

    /**
     * @brief Gets the size of the stack.
     *
     * @return Number of commands in stack
     */
    public int size() {
<span class="fc" id="L1183">      return size;</span>
    }

    /**
     * @brief Clears all commands from the stack.
     */
    public void clear() {
<span class="fc" id="L1190">      top = null;</span>
<span class="fc" id="L1191">      size = 0;</span>
<span class="fc" id="L1192">    }</span>
  }

  // ========== SERVICE DEPENDENCY GRAPH (BFS, DFS, SCC) ==========

  /**
   * @brief Graph data structure for tracking service dependencies.
   * @details Implements directed graph with BFS, DFS, and Strongly Connected Components (Kosaraju's algorithm).
   *
   * Time Complexity:
   * - addEdge: O(1)
   * - BFS: O(V + E)
   * - DFS: O(V + E)
   * - SCC: O(V + E)
   *
   * Space Complexity: O(V + E)
   */
  public static class ServiceGraph {
    private final Map&lt;String, List&lt;String&gt;&gt; adjacencyList;
    private final Map&lt;String, List&lt;String&gt;&gt; reverseAdjacencyList;

    /**
     * @brief Constructor initializes empty graph.
     */
<span class="fc" id="L1216">    public ServiceGraph() {</span>
<span class="fc" id="L1217">      this.adjacencyList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1218">      this.reverseAdjacencyList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1219">    }</span>

    /**
     * @brief Adds a directed edge from service1 to service2.
     * @details Represents that service1 depends on service2.
     *
     * @param service1 Source service
     * @param service2 Destination service
     */
    public void addEdge(String service1, String service2) {
<span class="fc" id="L1229">      adjacencyList.putIfAbsent(service1, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1230">      adjacencyList.putIfAbsent(service2, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1231">      adjacencyList.get(service1).add(service2);</span>
      // Build reverse graph for SCC
<span class="fc" id="L1233">      reverseAdjacencyList.putIfAbsent(service1, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1234">      reverseAdjacencyList.putIfAbsent(service2, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1235">      reverseAdjacencyList.get(service2).add(service1);</span>
<span class="fc" id="L1236">    }</span>

    /**
     * @brief Breadth-First Search traversal starting from a service.
     * @details Returns list of services reachable from start in BFS order.
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @param start Starting service
     * @return List of services in BFS order
     */
    public List&lt;String&gt; bfs(String start) {
<span class="fc bfc" id="L1249" title="All 2 branches covered.">      if (!adjacencyList.containsKey(start)) {</span>
<span class="fc" id="L1250">        return new ArrayList&lt;&gt;();</span>
      }

<span class="fc" id="L1253">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1254">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1255">      Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1256">      queue.offer(start);</span>
<span class="fc" id="L1257">      visited.add(start);</span>

<span class="fc bfc" id="L1259" title="All 2 branches covered.">      while (!queue.isEmpty()) {</span>
<span class="fc" id="L1260">        String current = queue.poll();</span>
<span class="fc" id="L1261">        result.add(current);</span>
<span class="fc" id="L1262">        List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">        if (neighbors != null) {</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">          for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">            if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1267">              visited.add(neighbor);</span>
<span class="fc" id="L1268">              queue.offer(neighbor);</span>
            }
<span class="fc" id="L1270">          }</span>
        }
<span class="fc" id="L1272">      }</span>

<span class="fc" id="L1274">      return result;</span>
    }

    /**
     * @brief Depth-First Search traversal starting from a service.
     * @details Returns list of services reachable from start in DFS order.
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @param start Starting service
     * @return List of services in DFS order
     */
    public List&lt;String&gt; dfs(String start) {
<span class="fc bfc" id="L1288" title="All 2 branches covered.">      if (!adjacencyList.containsKey(start)) {</span>
<span class="fc" id="L1289">        return new ArrayList&lt;&gt;();</span>
      }

<span class="fc" id="L1292">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1293">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1294">      dfsHelper(start, visited, result);</span>
<span class="fc" id="L1295">      return result;</span>
    }

    /**
     * @brief Helper method for DFS traversal.
     *
     * @param current Current service being visited
     * @param visited Set of visited services
     * @param result List to store DFS order
     */
    private void dfsHelper(String current, Set&lt;String&gt; visited, List&lt;String&gt; result) {
<span class="fc" id="L1306">      visited.add(current);</span>
<span class="fc" id="L1307">      result.add(current);</span>
<span class="fc" id="L1308">      List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1310" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1313">            dfsHelper(neighbor, visited, result);</span>
          }
<span class="fc" id="L1315">        }</span>
      }
<span class="fc" id="L1317">    }</span>

    /**
     * @brief Finds all Strongly Connected Components using Kosaraju's algorithm.
     * @details A SCC is a maximal set of vertices where each vertex is reachable from every other.
     *
     * Algorithm:
     * 1. Perform DFS on original graph to get finish times
     * 2. Perform DFS on reversed graph in decreasing finish time order
     * 3. Each DFS tree in step 2 is a SCC
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @return List of SCCs, each SCC is a list of services
     */
    public List&lt;List&lt;String&gt;&gt; findStronglyConnectedComponents() {
<span class="fc" id="L1334">      List&lt;List&lt;String&gt;&gt; sccs = new ArrayList&lt;&gt;();</span>
      // Step 1: Get finish times using DFS
<span class="fc" id="L1336">      Stack&lt;String&gt; finishStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L1337">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L1339" title="All 2 branches covered.">      for (String service : adjacencyList.keySet()) {</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">        if (!visited.contains(service)) {</span>
<span class="fc" id="L1341">          fillFinishStack(service, visited, finishStack);</span>
        }
<span class="fc" id="L1343">      }</span>

      // Step 2: Process vertices in decreasing finish time order on reversed graph
<span class="fc" id="L1346">      visited.clear();</span>

<span class="fc bfc" id="L1348" title="All 2 branches covered.">      while (!finishStack.isEmpty()) {</span>
<span class="fc" id="L1349">        String service = finishStack.pop();</span>

<span class="fc bfc" id="L1351" title="All 2 branches covered.">        if (!visited.contains(service)) {</span>
<span class="fc" id="L1352">          List&lt;String&gt; scc = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1353">          dfsReverse(service, visited, scc);</span>
<span class="fc" id="L1354">          sccs.add(scc);</span>
        }
<span class="fc" id="L1356">      }</span>

<span class="fc" id="L1358">      return sccs;</span>
    }

    /**
     * @brief Fills stack with services in order of finish time.
     *
     * @param current Current service
     * @param visited Set of visited services
     * @param finishStack Stack to store finish order
     */
    private void fillFinishStack(String current, Set&lt;String&gt; visited, Stack&lt;String&gt; finishStack) {
<span class="fc" id="L1369">      visited.add(current);</span>
<span class="fc" id="L1370">      List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1375">            fillFinishStack(neighbor, visited, finishStack);</span>
          }
<span class="fc" id="L1377">        }</span>
      }

<span class="fc" id="L1380">      finishStack.push(current);</span>
<span class="fc" id="L1381">    }</span>

    /**
     * @brief DFS on reversed graph to find a SCC.
     *
     * @param current Current service
     * @param visited Set of visited services
     * @param scc List to store current SCC
     */
    private void dfsReverse(String current, Set&lt;String&gt; visited, List&lt;String&gt; scc) {
<span class="fc" id="L1391">      visited.add(current);</span>
<span class="fc" id="L1392">      scc.add(current);</span>
<span class="fc" id="L1393">      List&lt;String&gt; neighbors = reverseAdjacencyList.get(current);</span>

<span class="pc bpc" id="L1395" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1396" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1398">            dfsReverse(neighbor, visited, scc);</span>
          }
<span class="fc" id="L1400">        }</span>
      }
<span class="fc" id="L1402">    }</span>

    /**
     * @brief Gets all services in the graph.
     *
     * @return Set of all service names
     */
    public Set&lt;String&gt; getAllServices() {
<span class="fc" id="L1410">      return new HashSet&lt;&gt;(adjacencyList.keySet());</span>
    }

    /**
     * @brief Gets neighbors of a service.
     *
     * @param service Service name
     * @return List of neighboring services
     */
    public List&lt;String&gt; getNeighbors(String service) {
<span class="fc" id="L1420">      List&lt;String&gt; neighbors = adjacencyList.get(service);</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">      return neighbors != null ? new ArrayList&lt;&gt;(neighbors) : new ArrayList&lt;&gt;();</span>
    }

    /**
     * @brief Checks if graph contains a service.
     *
     * @param service Service name
     * @return true if service exists in graph
     */
    public boolean containsService(String service) {
<span class="fc" id="L1431">      return adjacencyList.containsKey(service);</span>
    }

    /**
     * @brief Clears the graph.
     */
    public void clear() {
<span class="fc" id="L1438">      adjacencyList.clear();</span>
<span class="fc" id="L1439">      reverseAdjacencyList.clear();</span>
<span class="fc" id="L1440">    }</span>
  }

  /**
   * @brief Analyzes service dependencies and returns related services.
   * @details Uses BFS to find all services reachable from the given service.
   *
   * @param service Service name
   * @return List of related services
   */
  public List&lt;String&gt; getRelatedServices(String service) {
<span class="fc" id="L1451">    return serviceGraph.bfs(service);</span>
  }

  /**
   * @brief Adds a dependency relationship between two services.
   *
   * @param service1 Source service
   * @param service2 Dependent service
   */
  public void addServiceDependency(String service1, String service2) {
<span class="fc" id="L1461">    serviceGraph.addEdge(service1, service2);</span>
<span class="fc" id="L1462">  }</span>

  /**
   * @brief Gets all strongly connected components in service dependencies.
   *
   * @return List of SCCs
   */
  public List&lt;List&lt;String&gt;&gt; getServiceClusters() {
<span class="fc" id="L1470">    return serviceGraph.findStronglyConnectedComponents();</span>
  }

  /**
   * @brief Gets the service dependency graph.
   *
   * @return ServiceGraph instance
   */
  public ServiceGraph getServiceGraph() {
<span class="fc" id="L1479">    return serviceGraph;</span>
  }

  /**
   * @brief Queues a pending operation.
   *
   * @param operation Operation description
   */
  public void queueOperation(String operation) {
<span class="fc" id="L1488">    operationsQueue.enqueue(operation);</span>
<span class="fc" id="L1489">  }</span>

  /**
   * @brief Processes all pending operations.
   *
   * @return List of processed operations
   */
  public List&lt;String&gt; processPendingOperations() {
<span class="fc" id="L1497">    List&lt;String&gt; processed = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1499" title="All 2 branches covered.">    while (!operationsQueue.isEmpty()) {</span>
<span class="fc" id="L1500">      processed.add(operationsQueue.dequeue());</span>
    }

<span class="fc" id="L1503">    return processed;</span>
  }

  /**
   * @brief Gets the count of pending operations.
   *
   * @return Number of pending operations
   */
  public int getPendingOperationsCount() {
<span class="fc" id="L1512">    return operationsQueue.size();</span>
  }

  /**
   * @brief Peeks at the next pending operation without removing it.
   *
   * @return Next operation or null if queue is empty
   */
  public String peekNextOperation() {
<span class="fc" id="L1521">    return operationsQueue.peek();</span>
  }

  /**
   * @brief Gets the pending operations queue.
   *
   * @return PendingOperationsQueue instance
   */
  public PendingOperationsQueue getOperationsQueue() {
<span class="fc" id="L1530">    return operationsQueue;</span>
  }

  /**
   * @brief Custom Queue implementation using linked nodes.
   *
   * Implements FIFO (First-In-First-Out) data structure for pending operations.
   */
  public static class PendingOperationsQueue {
    /**
     * @brief Node class for queue elements.
     */
    private static class Node {
      /** @brief The operation stored in this node */
      String operation;
      /** @brief Reference to the next node */
      Node next;

      /**
       * @brief Constructs a node with the given operation.
       * @param operation The operation to store
       */
<span class="fc" id="L1552">      Node(String operation) {</span>
<span class="fc" id="L1553">        this.operation = operation;</span>
<span class="fc" id="L1554">        this.next = null;</span>
<span class="fc" id="L1555">      }</span>
    }

    /** @brief Front of queue (dequeue from here) */
    private Node front;
    /** @brief Rear of queue (enqueue to here) */
    private Node rear;
    /** @brief Current number of elements in the queue */
    private int size;

    /**
     * @brief Constructor initializing empty queue.
     */
<span class="fc" id="L1568">    public PendingOperationsQueue() {</span>
<span class="fc" id="L1569">      this.front = null;</span>
<span class="fc" id="L1570">      this.rear = null;</span>
<span class="fc" id="L1571">      this.size = 0;</span>
<span class="fc" id="L1572">    }</span>

    /**
     * @brief Adds an operation to the rear of the queue.
     *
     * Time complexity: O(1)
     *
     * @param operation Operation to enqueue
     */
    public void enqueue(String operation) {
<span class="fc" id="L1582">      Node newNode = new Node(operation);</span>

<span class="fc bfc" id="L1584" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1585">        front = newNode;</span>
<span class="fc" id="L1586">        rear = newNode;</span>
      } else {
<span class="fc" id="L1588">        rear.next = newNode;</span>
<span class="fc" id="L1589">        rear = newNode;</span>
      }

<span class="fc" id="L1592">      size++;</span>
<span class="fc" id="L1593">    }</span>

    /**
     * @brief Removes and returns the operation from the front of the queue.
     *
     * Time complexity: O(1)
     *
     * @return Front operation, or null if queue is empty
     */
    public String dequeue() {
<span class="fc bfc" id="L1603" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1604">        return null;</span>
      }

<span class="fc" id="L1607">      String operation = front.operation;</span>
<span class="fc" id="L1608">      front = front.next;</span>

<span class="fc bfc" id="L1610" title="All 2 branches covered.">      if (front == null) {</span>
<span class="fc" id="L1611">        rear = null;  // Queue is now empty</span>
      }

<span class="fc" id="L1614">      size--;</span>
<span class="fc" id="L1615">      return operation;</span>
    }

    /**
     * @brief Returns the operation at the front without removing it.
     *
     * Time complexity: O(1)
     *
     * @return Front operation, or null if queue is empty
     */
    public String peek() {
<span class="fc bfc" id="L1626" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1627">        return null;</span>
      }

<span class="fc" id="L1630">      return front.operation;</span>
    }

    /**
     * @brief Checks if the queue is empty.
     *
     * Time complexity: O(1)
     *
     * @return true if queue is empty, false otherwise
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1641" title="All 2 branches covered.">      return size == 0;</span>
    }

    /**
     * @brief Gets the current size of the queue.
     *
     * Time complexity: O(1)
     *
     * @return Number of operations in the queue
     */
    public int size() {
<span class="fc" id="L1652">      return size;</span>
    }

    /**
     * @brief Clears all operations from the queue.
     *
     * Time complexity: O(1)
     */
    public void clear() {
<span class="fc" id="L1661">      front = null;</span>
<span class="fc" id="L1662">      rear = null;</span>
<span class="fc" id="L1663">      size = 0;</span>
<span class="fc" id="L1664">    }</span>

    /**
     * @brief Gets all operations as a list without removing them.
     *
     * Time complexity: O(n)
     *
     * @return List of all operations in FIFO order
     */
    public List&lt;String&gt; toList() {
<span class="fc" id="L1674">      List&lt;String&gt; operations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1675">      Node current = front;</span>

<span class="fc bfc" id="L1677" title="All 2 branches covered.">      while (current != null) {</span>
<span class="fc" id="L1678">        operations.add(current.operation);</span>
<span class="fc" id="L1679">        current = current.next;</span>
      }

<span class="fc" id="L1682">      return operations;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>